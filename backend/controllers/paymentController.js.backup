const asyncHandler = require('express-async-handler');
const Payment = require('../models/Payment');
const Event = require('../models/Event');
const Ticket = require('../models/Ticket');
const mongoose = require('mongoose');
const VietQRService = require('../services/vietqrService');
const PayOSService = require('../services/payosService');
const Booking = require('../models/Booking');
const TicketType = require('../models/TicketType');

// Initialize services
const vietqrService = new VietQRService();
const payosService = new PayOSService();

function sanitizeOrderInfo(str) {
    return str
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/ƒë/g, 'd')
        .replace(/ƒê/g, 'D')
        .replace(/[^a-zA-Z0-9 \-_]/g, '');
}

// @desc    T·∫°o URL thanh to√°n VNPay
// @route   POST /api/payments/create-payment-url
// @access  Private
const createPaymentUrl = asyncHandler(async (req, res) => {
    const { eventId, selectedSeats = [], selectedTickets = [], bookingType = 'seat', bankCode } = req.body;

    try {
        // Validate input based on booking type
        if (!eventId) {
            return res.status(400).json({
                success: false,
                message: 'Vui l√≤ng cung c·∫•p th√¥ng tin s·ª± ki·ªán'
            });
        }

        if (bookingType === 'simple') {
            if (!selectedTickets || selectedTickets.length === 0) {
                return res.status(400).json({
                    success: false,
                    message: 'Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt lo·∫°i v√©'
                });
            }
        } else {
            if (!selectedSeats || selectedSeats.length === 0) {
                return res.status(400).json({
                    success: false,
                    message: 'Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt gh·∫ø'
                });
            }
        }

        // ===== CRITICAL FIX: Validate eventId is not string "null" or "undefined" =====
        if (eventId === "null" || eventId === "undefined" || eventId === null || eventId === undefined) {
            console.error('Invalid eventId received:', eventId, typeof eventId);
            return res.status(400).json({
                success: false,
                message: 'ID s·ª± ki·ªán kh√¥ng h·ª£p l·ªá. Vui l√≤ng ch·ªçn l·∫°i s·ª± ki·ªán.'
            });
        }

        // Get event details
        const event = await Event.findById(eventId);
        if (!event) {
            return res.status(404).json({
                success: false,
                message: 'Kh√¥ng t√¨m th·∫•y s·ª± ki·ªán'
            });
        }

        // Calculate total amount based on booking type
        let totalAmount = 0;
        
        if (bookingType === 'simple') {
            for (const ticket of selectedTickets) {
                totalAmount += (ticket.price || 0) * (ticket.quantity || 0);
            }
        } else {
            for (const seat of selectedSeats) {
                totalAmount += seat.price || 0;
            }
        }

        if (totalAmount <= 0) {
            return res.status(400).json({
                success: false,
                message: 'S·ªë ti·ªÅn thanh to√°n kh√¥ng h·ª£p l·ªá'
            });
        }

        // Create unique transaction reference for POS
        const pos_TxnRef = `POS_${eventId}_${Date.now()}_${Math.random().toString(36).substring(7)}`;
        
        const orderInfo = sanitizeOrderInfo(`Thanh toan ve ${event.title}`);

        console.log('üí≥ Creating POS payment:', {
            eventId,
            selectedSeats,
            selectedTickets,
            totalAmount,
            bookingType,
            userId: req.user._id
        });

        // Create payment record
        const payment = new Payment({
            user: req.user._id,
            event: eventId,
            totalAmount: totalAmount,
            selectedSeats: selectedSeats.map(s => ({
                _id: s._id,
                sectionName: s.sectionName,
                rowName: s.rowName,
                seatNumber: s.seatNumber,
                price: s.price,
                ticketType: s.ticketType,
            })),
            selectedTickets: selectedTickets.map(t => ({
                ticketTypeId: t.ticketTypeId,
                quantity: t.quantity,
                price: t.price,
                ticketTypeName: t.name
            })),
            bookingType: bookingType,
            pos_TxnRef,
            orderInfo: orderInfo,
            status: 'pending',
            paymentMethod: 'pos'
        });

        await payment.save();

        // Generate VietQR
        console.log('üè¶ Generating VietQR...');
        const vietqrResult = await vietqrService.generateVietQR(
            totalAmount,
            pos_TxnRef,
            pos_TxnRef
        );

        if (!vietqrResult || !vietqrResult.qrDataURL) {
            throw new Error('Failed to generate VietQR');
        }

        console.log('‚úÖ VietQR generated successfully');

        // Try to generate PayOS (optional - if fails, still return success with VietQR)
        let payosResult = null;
        try {
            console.log('üí∞ Creating PayOS payment link...');
            const orderCode = payosService.generateOrderCode('POS');
            
            const items = payosService.formatOrderItems(selectedTickets, selectedSeats);
            
            console.log('üí∞ Creating PayOS payment with data:', {
                orderCode,
                amount: totalAmount,
                description: orderInfo,
                itemsCount: items.length
            });

            payosResult = await payosService.createPaymentLink({
                orderCode: orderCode,
                amount: totalAmount,
                description: orderInfo,
                items: items,
                buyerInfo: {
                    name: req.user.name || req.user.email || 'Customer',
                    email: req.user.email || '',
                    phone: req.user.phone || ''
                }
            });

            if (payosResult && payosResult.success) {
                console.log('‚úÖ PayOS payment link created successfully');
            } else {
                console.log('‚ö†Ô∏è PayOS payment creation failed, continuing with VietQR only');
                payosResult = null;
            }
        } catch (payosError) {
            console.log('‚ö†Ô∏è PayOS payment creation failed:', payosError.message);
            console.log('üì± Continuing with VietQR only...');
            payosResult = null;
        }

        // Update payment with results
        payment.vietqr_qrDataURL = vietqrResult.qrDataURL;
        payment.vietqr_bankInfo = vietqrResult.bankInfo;
        payment.vietqr_isFallback = vietqrResult.isFallback;
        
        if (payosResult && payosResult.success) {
            payment.payos_orderCode = payosResult.orderCode;
            payment.payos_checkoutUrl = payosResult.checkoutUrl;
            payment.payos_paymentLinkId = payosResult.paymentLinkId;
        }

        await payment.save();

        console.log('üí≥ POS payment created:', {
            paymentId: payment._id,
            pos_TxnRef,
            totalAmount
        });

        // Prepare response
        const response = {
            success: true,
            paymentId: payment._id,
            pos_TxnRef,
            totalAmount,
            vietqr: {
                qrDataURL: vietqrResult.qrDataURL,
                bankInfo: vietqrResult.bankInfo,
                isFallback: vietqrResult.isFallback
            }
        };

        // Add PayOS info if available
        if (payosResult && payosResult.success) {
            response.payos = {
                orderCode: payosResult.orderCode,
                checkoutUrl: payosResult.checkoutUrl,
                paymentLinkId: payosResult.paymentLinkId
            };
        }

        res.json(response);

    } catch (error) {
        console.error('Payment creation error:', error);
        res.status(500).json({
            success: false,
            message: 'L·ªói t·∫°o thanh to√°n: ' + error.message
        });
    }
});

// @desc    X·ª≠ l√Ω callback t·ª´ VNPay
// @route   GET /api/payments/vnpay-callback
// @access  Public
const vnpayCallback = asyncHandler(async (req, res) => {
    try {
        const vnp_Params = req.query;
        const vnp_TxnRef = vnp_Params['vnp_TxnRef'];
        const vnp_ResponseCode = vnp_Params['vnp_ResponseCode'];

        // Verify the callback
        const verificationResult = vnpayService.verifyReturnUrl(vnp_Params);

        if (!verificationResult.isSuccess) {
            return res.status(400).json({
                success: false,
                message: 'Ch·ªØ k√Ω kh√¥ng h·ª£p l·ªá'
            });
        }

        // Find the payment record
        const payment = await Payment.findOne({ pos_TxnRef: vnp_TxnRef }).populate('event user');

        if (!payment) {
            return res.status(404).json({
                success: false,
                message: 'Kh√¥ng t√¨m th·∫•y giao d·ªãch'
            });
        }

        // Update payment with VNPay response
        payment.vnp_ResponseCode = vnp_ResponseCode;
        payment.vnp_BankCode = vnp_Params['vnp_BankCode'];
        payment.vnp_BankTranNo = vnp_Params['vnp_BankTranNo'];
        payment.vnp_CardType = vnp_Params['vnp_CardType'];
        payment.vnp_PayDate = vnp_Params['vnp_PayDate'];
        payment.vnp_TransactionNo = vnp_Params['vnp_TransactionNo'];
        payment.vnp_TransactionStatus = vnp_Params['vnp_TransactionStatus'];
        payment.vnp_SecureHash = vnp_Params['vnp_SecureHash'];

        if (vnp_ResponseCode === '00') {
            // Payment successful, now create tickets and update seats.
            try {
                const event = await Event.findById(payment.event).populate('ticketTypes');
                if (!event) {
                    throw new Error(`Event with ID ${payment.event} not found during callback processing.`);
                }

                for (const seatInfo of payment.selectedSeats) {
                    // ===== DEBUG: Log chi ti·∫øt t·ª´ng seat tr∆∞·ªõc khi t·∫°o ticket =====
                    console.log('=== CREATING TICKET FOR SEAT ===');
                    console.log('seatInfo object:', JSON.stringify(seatInfo, null, 2));
                    console.log('seatInfo.sectionName:', seatInfo.sectionName);
                    console.log('seatInfo.rowName:', seatInfo.rowName);
                    console.log('seatInfo.seatNumber:', seatInfo.seatNumber);
                    console.log('seatInfo.ticketType:', seatInfo.ticketType);
                    console.log('typeof seatInfo.ticketType:', typeof seatInfo.ticketType);
                    console.log('================================');

                    // ===== CRITICAL FIX: Ensure ticketType is never undefined =====
                    let finalTicketType = seatInfo.ticketType;
                    
                    // If ticketType is missing, try to determine it from the event's seating map
                    if (!finalTicketType || finalTicketType === 'undefined' || finalTicketType === 'null') {
                        console.log('‚ö†Ô∏è WARNING: ticketType is missing! Attempting to recover...');
                        
                        // Find the section and get ticket type from event data
                        const section = event.seatingMap?.sections?.find(s => s.name === seatInfo.sectionName);
                        if (section?.ticketTier) {
                            // Try to get ticket type name from event's ticketTypes
                            const ticketTypeObj = event.ticketTypes?.find(tt => tt._id.toString() === section.ticketTier.toString());
                            finalTicketType = ticketTypeObj?.name || 'Standard';
                            console.log(`‚úÖ Recovered ticketType: ${finalTicketType}`);
                        } else {
                            // Ultimate fallback
                            finalTicketType = 'Standard';
                            console.log(`üîß Using fallback ticketType: ${finalTicketType}`);
                        }
                    }
                    
                    console.log(`üìù Final ticketType to be used: "${finalTicketType}"`);
                    // ================================================================

                    // Create a new ticket for each selected seat
                    const newTicket = new Ticket({
                        event: payment.event,
                        user: payment.user,
                        price: seatInfo.price,
                        purchaseDate: new Date(),
                        status: 'active',
                        ticketType: finalTicketType, // Use the validated/recovered ticketType
                        seat: {
                            section: seatInfo.sectionName,
                            row: seatInfo.rowName,
                            seatNumber: seatInfo.seatNumber,
                        },
                    });

                    console.log('=== TICKET OBJECT BEFORE SAVE ===');
                    console.log('ticketType in newTicket:', newTicket.ticketType);
                    console.log('newTicket object:', JSON.stringify(newTicket.toObject(), null, 2));
                    console.log('==================================');

                    const savedTicket = await newTicket.save();
                    console.log('‚úÖ TICKET SAVED SUCCESSFULLY!');
                    console.log('Saved ticket ID:', savedTicket._id);
                    console.log('Saved ticket user:', savedTicket.user);
                    console.log('Saved ticket event:', savedTicket.event);
                    console.log('Saved ticket price:', savedTicket.price);
                    console.log('Saved ticket status:', savedTicket.status);
                    console.log('===========================');

                    // Find the corresponding seat in the event and mark it as sold
                    console.log('=== UPDATING SEAT STATUS ===');
                    console.log('Looking for seat:', seatInfo.sectionName, seatInfo.rowName, seatInfo.seatNumber);
                    console.log('seatInfo._id:', seatInfo._id);
                    console.log('Event seatingMap sections:', event.seatingMap?.sections?.length);
                    
                    const section = event.seatingMap.sections.find(s => s.name === seatInfo.sectionName);
                    console.log('Found section:', !!section, section?.name);
                    
                    if (section) {
                        let seatFound = false;
                        
                        // Method 1: Try to find by rowName and seatNumber if available
                        if (seatInfo.rowName && seatInfo.seatNumber) {
                            console.log('üîç Method 1: Searching by rowName and seatNumber');
                            const row = section.rows.find(r => r.name === seatInfo.rowName);
                            console.log('Found row:', !!row, row?.name);
                            
                            if (row) {
                                const seat = row.seats.find(s => 
                                    s.number === seatInfo.seatNumber || 
                                    s.seatNumber === seatInfo.seatNumber ||
                                    s.number === String(seatInfo.seatNumber) ||
                                    s.seatNumber === String(seatInfo.seatNumber)
                                );
                                console.log('Found seat by row/number:', !!seat, seat?.number || seat?.seatNumber);
                                
                                if (seat) {
                                    console.log('‚úÖ Method 1: Marking seat as sold');
                                    seat.status = 'sold';
                                    seatFound = true;
                                }
                            }
                        }
                        
                        // Method 2: If Method 1 failed, try to find by _id across all rows
                        if (!seatFound && seatInfo._id) {
                            console.log('üîç Method 2: Searching by _id across all rows');
                            for (const row of section.rows) {
                                const seat = row.seats.find(s => s._id.toString() === seatInfo._id.toString());
                                if (seat) {
                                    console.log('‚úÖ Method 2: Found seat by _id:', seat._id, 'in row:', row.name);
                                    console.log('Seat details:', { number: seat.number, status: seat.status });
                                    seat.status = 'sold';
                                    seatFound = true;
                                    break;
                                }
                            }
                        }
                        
                        // Method 3: If both methods failed, try to find by _id in the entire seating map
                        if (!seatFound && seatInfo._id) {
                            console.log('üîç Method 3: Searching by _id in entire seating map');
                            for (const anySection of event.seatingMap.sections) {
                                for (const anyRow of anySection.rows) {
                                    const seat = anyRow.seats.find(s => s._id.toString() === seatInfo._id.toString());
                                    if (seat) {
                                        console.log('‚úÖ Method 3: Found seat by _id:', seat._id, 'in section:', anySection.name, 'row:', anyRow.name);
                                        console.log('Seat details:', { number: seat.number, status: seat.status });
                                        seat.status = 'sold';
                                        seatFound = true;
                                        break;
                                    }
                                }
                                if (seatFound) break;
                            }
                        }
                        
                        if (!seatFound) {
                            console.log('‚ùå SEAT NOT FOUND by any method');
                            console.log('Available rows in section:', section.rows.map(r => r.name));
                            if (section.rows.length > 0) {
                                console.log('Sample seats in first row:', section.rows[0].seats.slice(0, 3).map(s => ({
                                    _id: s._id,
                                    number: s.number,
                                    status: s.status
                                })));
                            }
                        } else {
                            console.log('‚úÖ SEAT STATUS UPDATED SUCCESSFULLY');
                        }
                    } else {
                        console.log('‚ùå Section not found in event');
                        console.log('Available sections:', event.seatingMap?.sections?.map(s => s.name));
                    }
                    console.log('=============================');
                }

                // Mark event as dirty to save changes to seating arrangement
                event.markModified('seatingMap');
                await event.save();

                // If all tickets are created successfully, update payment status to 'success'
                payment.status = 'success';
                
            } catch (ticketError) {
                console.error('VNPay callback error during ticket/seat processing:', ticketError);
                // If any error occurs during ticket creation, set payment status to 'failed'
                payment.status = 'failed'; // Corrected: Use valid enum 'failed'
            }

        } else {
            // Payment was not successful with VNPay
            payment.status = 'failed';
        }

        // Save the final payment status
        await payment.save();
        console.log(`Payment ${payment._id} processed with final status: ${payment.status}`);

        // Redirect user to frontend with payment result
        const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
        
        if (payment.status === 'success') {
            console.log(`‚úÖ Payment successful! Redirecting to success page`);
            res.redirect(`${frontendUrl}/payment/success?pos_TxnRef=${vnp_TxnRef}&amount=${payment.totalAmount}`);
        } else {
            console.log(`‚ùå Payment failed! Redirecting to failure page`);
            res.redirect(`${frontendUrl}/payment/failure?pos_TxnRef=${vnp_TxnRef}&reason=${vnp_ResponseCode}`);
        }

    } catch (error) {
        console.error('VNPay callback error:', error);
        // Redirect to failure page if any internal error occurs
        const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
        res.redirect(`${frontendUrl}/payment/failure?reason=internal&message=${encodeURIComponent(error.message)}`);
    }
});

// @desc    T·∫°o thanh to√°n POS v·ªõi VietQR v√† PayOS
// @route   POST /api/payments/create-pos-payment
// @access  Private
const createPOSPayment = asyncHandler(async (req, res) => {
    try {
        const { eventId, selectedSeats = [], selectedTickets = [], totalAmount, bookingType = 'seating' } = req.body;

        console.log('üí≥ Creating POS payment:', {
            eventId,
            selectedSeats,
            selectedTickets,
            totalAmount,
            bookingType,
            userId: req.user._id
        });

        // Validate required fields
        if (!eventId || !totalAmount) {
            return res.status(400).json({
                success: false,
                message: 'Missing required fields: eventId, totalAmount'
            });
        }

        if (bookingType === 'seating' && (!selectedSeats || selectedSeats.length === 0)) {
            return res.status(400).json({
                success: false,
                message: 'Selected seats are required for seating events'
            });
        }

        if (bookingType === 'simple' && (!selectedTickets || selectedTickets.length === 0)) {
            return res.status(400).json({
                success: false,
                message: 'Selected tickets are required for simple events'
            });
        }

        // Get event details
        const event = await Event.findById(eventId);
        if (!event) {
            return res.status(404).json({
                success: false,
                message: 'Kh√¥ng t√¨m th·∫•y s·ª± ki·ªán'
            });
        }

        // Create payment reference
        const pos_TxnRef = `POS_${eventId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const orderCode = payosService.generateOrderCode('EVT');
        
        // Create descriptions
        const description = `Thanh toan ve ${event.title}`;
        const addInfo = pos_TxnRef;

        console.log('üè¶ Generating VietQR...');
        // Generate VietQR
        let vietqrResult;
        try {
            vietqrResult = await vietqrService.generateVietQR(totalAmount, description, addInfo);
            console.log('‚úÖ VietQR generated:', vietqrResult.success ? 'Success' : 'Failed');
        } catch (error) {
            console.error('‚ùå VietQR error:', error.message);
            vietqrResult = { success: false, error: error.message };
        }

        console.log('üí∞ Creating PayOS payment link...');
        // Create PayOS payment link
        let payosResult;
        try {
            const items = payosService.formatOrderItems(selectedTickets, selectedSeats);
            const buyerInfo = {
                name: req.user.name || req.user.email,
                email: req.user.email,
                phone: req.user.phone || ''
            };

            payosResult = await payosService.createPaymentLink({
                orderCode: orderCode,
                amount: totalAmount,
                description: description,
                items: items,
                buyerInfo: buyerInfo
            });
            console.log('‚úÖ PayOS generated:', payosResult.success ? 'Success' : 'Failed');
        } catch (error) {
            console.error('‚ùå PayOS error:', error.message);
            payosResult = { success: false, error: error.message };
        }

        // Create payment record
        const payment = new Payment({
            user: req.user._id,
            event: eventId,
            totalAmount: totalAmount,
            selectedSeats: bookingType === 'seating' ? selectedSeats : [],
            selectedTickets: bookingType === 'simple' ? selectedTickets : [],
            bookingType: bookingType,
            paymentMethod: 'pos',
            status: 'pending',
            pos_TxnRef: pos_TxnRef,
            
            // VietQR data
            vietqr_qrDataURL: vietqrResult.success ? vietqrResult.qrDataURL : null,
            vietqr_bankInfo: vietqrResult.success ? vietqrResult.bankInfo : null,
            vietqr_isFallback: vietqrResult.isFallback || false,
            
            // PayOS data
            payos_orderCode: orderCode,
            payos_checkoutUrl: payosResult.success ? payosResult.checkoutUrl : null,
            payos_paymentLinkId: payosResult.success ? payosResult.paymentLinkId : null,
            
            createdAt: new Date()
        });

        await payment.save();

        console.log('üí≥ POS payment created:', {
            paymentId: payment._id,
            pos_TxnRef,
            totalAmount
        });

        res.json({
            success: true,
            pos_TxnRef,
            totalAmount,
            paymentId: payment._id,
            
            // VietQR data
            vietqr: vietqrResult.success ? {
                qrDataURL: vietqrResult.qrDataURL,
                bankInfo: vietqrResult.bankInfo,
                isFallback: vietqrResult.isFallback
            } : null,
            
            // PayOS data
            payos: payosResult.success ? {
                checkoutUrl: payosResult.checkoutUrl,
                orderCode: orderCode,
                qrCode: payosResult.qrCode
            } : null,
            
            message: 'Thanh to√°n POS ƒë√£ s·∫µn s√†ng v·ªõi VietQR v√† PayOS'
        });

    } catch (error) {
        console.error('POS payment creation error:', error);
        res.status(500).json({
            success: false,
            message: 'L·ªói t·∫°o thanh to√°n POS: ' + error.message
        });
    }
});

// @desc    X·ª≠ l√Ω return t·ª´ PayOS
// @route   GET /api/payments/payos-return
// @access  Public
const handlePayOSReturn = asyncHandler(async (req, res) => {
    try {
        const { code, id, cancel, status, orderCode } = req.query;

        console.log('üîÑ PayOS return:', { code, id, cancel, status, orderCode });

        const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';

        if (cancel === 'true') {
            // Payment was cancelled
            const payment = await Payment.findOne({ payos_orderCode: orderCode });
            if (payment) {
                payment.status = 'cancelled';
                await payment.save();
            }
            
            return res.redirect(`${frontendUrl}/payment/failure?reason=cancelled`);
        }

        if (code === '00') {
            // Payment successful
            const payment = await Payment.findOne({ payos_orderCode: orderCode }).populate('event user');
            if (payment) {
                payment.status = 'success';
                payment.payos_status = 'PAID';
                payment.payos_transactionDateTime = new Date();
                await payment.save();
                
                console.log('‚úÖ PayOS payment successful');
            }
            
            return res.redirect(`${frontendUrl}/payment/success?orderCode=${orderCode}`);
        } else {
            // Payment failed
            const payment = await Payment.findOne({ payos_orderCode: orderCode });
            if (payment) {
                payment.status = 'failed';
                await payment.save();
            }
            
            return res.redirect(`${frontendUrl}/payment/failure?reason=failed&code=${code}`);
        }

    } catch (error) {
        console.error('PayOS return error:', error);
        const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
        res.redirect(`${frontendUrl}/payment/failure?reason=error`);
    }
});

// @desc    X·ª≠ l√Ω webhook t·ª´ PayOS
// @route   POST /api/payments/payos-webhook
// @access  Public
const handlePayOSWebhook = asyncHandler(async (req, res) => {
    try {
        const webhookData = req.body;

        console.log('üîî PayOS webhook received:', webhookData);

        // Verify webhook signature
        const isValid = payosService.verifyPaymentWebhookData(webhookData);
        if (!isValid) {
            console.log('‚ùå Invalid PayOS webhook signature');
            return res.status(400).json({ error: 'Invalid signature' });
        }

        const { orderCode, code, desc, data } = webhookData;
        
        if (code === '00' && data) {
            // Payment successful
            console.log('‚úÖ PayOS webhook: Payment successful');
            
            const payment = await Payment.findOne({ payos_orderCode: orderCode }).populate('event user');
            if (payment && payment.status !== 'completed') {
                payment.payos_status = 'PAID';
                payment.payos_transactionDateTime = new Date();
                payment.status = 'completed';
                await payment.save();
                
                console.log('üé´ PayOS payment completed');
            }
        } else {
            // Payment failed
            console.log('‚ùå PayOS webhook: Payment failed');
            
            const payment = await Payment.findOne({ payos_orderCode: orderCode });
            if (payment) {
                payment.payos_status = 'CANCELLED';
                payment.status = 'failed';
                await payment.save();
            }
        }

        res.status(200).json({ message: 'Webhook processed' });

    } catch (error) {
        console.error('PayOS webhook error:', error);
        res.status(500).json({ error: 'Webhook processing failed' });
    }
});

// @desc    L·∫•y danh s√°ch ph∆∞∆°ng th·ª©c thanh to√°n
// @route   GET /api/payments/methods
// @access  Public
const getPaymentMethods = asyncHandler(async (req, res) => {
    const methods = [
        { 
            code: 'pos', 
            name: 'Thanh to√°n t·∫°i qu·∫ßy POS', 
            description: 'Thanh to√°n tr·ª±c ti·∫øp t·∫°i qu·∫ßy v·ªõi VietQR v√† PayOS'
        },
        {
            code: 'vietqr',
            name: 'VietQR Banking',
            description: 'Thanh to√°n qua QR code banking'
        },
        {
            code: 'payos',
            name: 'PayOS',
            description: 'Thanh to√°n online qua PayOS'
        }
    ];
    
    res.json({
        success: true,
        methods
    });
});

// @desc    L·∫•y l·ªãch s·ª≠ thanh to√°n c·ªßa user
// @route   GET /api/payments/history
// @access  Private
const getPaymentHistory = asyncHandler(async (req, res) => {
    try {
        const payments = await Payment.find({ user: req.user._id })
            .populate('event', 'title date location images')
            .sort({ createdAt: -1 });

        res.json({
            success: true,
            payments
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'L·ªói l·∫•y l·ªãch s·ª≠ thanh to√°n: ' + error.message
        });
    }
});

// @desc    L·∫•y chi ti·∫øt thanh to√°n
// @route   GET /api/payments/:id
// @access  Private
const getPaymentDetail = asyncHandler(async (req, res) => {
    try {
        const payment = await Payment.findById(req.params.id).populate('event user');

        if (!payment) {
            return res.status(404).json({
                success: false,
                message: 'Kh√¥ng t√¨m th·∫•y th√¥ng tin thanh to√°n'
            });
        }

        // Check if user owns this payment or is admin
        if (payment.user._id.toString() !== req.user._id.toString() && req.user.role !== 'admin') {
            return res.status(403).json({
                success: false,
                message: 'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p th√¥ng tin thanh to√°n n√†y'
            });
        }

        res.json({
            success: true,
            payment
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'L·ªói l·∫•y th√¥ng tin thanh to√°n: ' + error.message
        });
    }
});

// Get all POS payments (Admin only)
exports.getPOSPayments = async (req, res) => {
    try {
        console.log('üîç Getting POS payments for admin');
        
        const payments = await Payment.find({ 
            paymentMethod: 'pos' 
        })
        .populate('userId', 'email fullName username')
        .populate('eventId', 'title')
        .sort({ createdAt: -1 });

        console.log(`üìä Found ${payments.length} POS payments`);

        const formattedPayments = payments.map(payment => ({
            _id: payment._id,
            pos_TxnRef: payment.pos_TxnRef,
            userEmail: payment.userId?.email,
            userName: payment.userId?.fullName || payment.userId?.username,
            eventTitle: payment.eventId?.title,
            totalAmount: payment.amount,
            status: payment.status,
            bookingType: payment.bookingType,
            selectedSeats: payment.selectedSeats,
            selectedTickets: payment.selectedTickets,
            createdAt: payment.createdAt,
            updatedAt: payment.updatedAt
        }));

        res.json({
            success: true,
            payments: formattedPayments
        });
    } catch (error) {
        console.error('‚ùå Error getting POS payments:', error);
        res.status(500).json({
            success: false,
            error: 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch POS payments'
        });
    }
};

// Confirm POS payment (Admin only)
exports.confirmPOSPayment = async (req, res) => {
    try {
        const { paymentId } = req.params;
        console.log('‚úÖ Confirming POS payment:', paymentId);

        const payment = await Payment.findById(paymentId);
        if (!payment) {
            return res.status(404).json({
                success: false,
                error: 'Kh√¥ng t√¨m th·∫•y giao d·ªãch thanh to√°n'
            });
        }

        if (payment.paymentMethod !== 'pos') {
            return res.status(400).json({
                success: false,
                error: 'ƒê√¢y kh√¥ng ph·∫£i l√† giao d·ªãch POS'
            });
        }

        if (payment.status === 'paid') {
            return res.status(400).json({
                success: false,
                error: 'Giao d·ªãch ƒë√£ ƒë∆∞·ª£c thanh to√°n'
            });
        }

        if (payment.status === 'cancelled') {
            return res.status(400).json({
                success: false,
                error: 'Giao d·ªãch ƒë√£ b·ªã h·ªßy'
            });
        }

        // Update payment status
        payment.status = 'paid';
        payment.paidAt = new Date();
        await payment.save();

        // Update booking status
        const booking = await Booking.findOne({ paymentId: payment._id });
        if (booking) {
            booking.status = 'confirmed';
            booking.confirmedAt = new Date();
            await booking.save();
            console.log('‚úÖ Updated booking status to confirmed');
        }

        // Generate tickets if seating event
        if (payment.bookingType === 'seating' && payment.selectedSeats) {
            await generateTicketsForSeats(payment);
        } else if (payment.selectedTickets) {
            await generateTicketsForTickets(payment);
        }

        console.log('‚úÖ POS payment confirmed successfully');

        res.json({
            success: true,
            message: 'X√°c nh·∫≠n thanh to√°n th√†nh c√¥ng',
            payment: {
                _id: payment._id,
                pos_TxnRef: payment.pos_TxnRef,
                status: payment.status,
                paidAt: payment.paidAt
            }
        });
    } catch (error) {
        console.error('‚ùå Error confirming POS payment:', error);
        res.status(500).json({
            success: false,
            error: 'Kh√¥ng th·ªÉ x√°c nh·∫≠n thanh to√°n'
        });
    }
};

// Cancel POS payment (Admin only)
exports.cancelPOSPayment = async (req, res) => {
    try {
        const { paymentId } = req.params;
        console.log('‚ùå Cancelling POS payment:', paymentId);

        const payment = await Payment.findById(paymentId);
        if (!payment) {
            return res.status(404).json({
                success: false,
                error: 'Kh√¥ng t√¨m th·∫•y giao d·ªãch thanh to√°n'
            });
        }

        if (payment.paymentMethod !== 'pos') {
            return res.status(400).json({
                success: false,
                error: 'ƒê√¢y kh√¥ng ph·∫£i l√† giao d·ªãch POS'
            });
        }

        if (payment.status === 'paid') {
            return res.status(400).json({
                success: false,
                error: 'Kh√¥ng th·ªÉ h·ªßy giao d·ªãch ƒë√£ thanh to√°n'
            });
        }

        if (payment.status === 'cancelled') {
            return res.status(400).json({
                success: false,
                error: 'Giao d·ªãch ƒë√£ b·ªã h·ªßy'
            });
        }

        // Update payment status
        payment.status = 'cancelled';
        payment.cancelledAt = new Date();
        await payment.save();

        // Update booking status
        const booking = await Booking.findOne({ paymentId: payment._id });
        if (booking) {
            booking.status = 'cancelled';
            booking.cancelledAt = new Date();
            await booking.save();
            console.log('‚ùå Updated booking status to cancelled');
        }

        // Release seats/tickets back to available
        await releaseSeatsAndTickets(payment);

        console.log('‚ùå POS payment cancelled successfully');

        res.json({
            success: true,
            message: 'H·ªßy thanh to√°n th√†nh c√¥ng',
            payment: {
                _id: payment._id,
                pos_TxnRef: payment.pos_TxnRef,
                status: payment.status,
                cancelledAt: payment.cancelledAt
            }
        });
    } catch (error) {
        console.error('‚ùå Error cancelling POS payment:', error);
        res.status(500).json({
            success: false,
            error: 'Kh√¥ng th·ªÉ h·ªßy thanh to√°n'
        });
    }
};

// Helper function to generate tickets for seats
const generateTicketsForSeats = async (payment) => {
    try {
        console.log('üé´ Generating tickets for seats');
        
        for (const seat of payment.selectedSeats) {
            const ticket = await Ticket.create({
                userId: payment.userId,
                eventId: payment.eventId,
                bookingId: payment.bookingId,
                paymentId: payment._id,
                ticketType: 'seating',
                seatId: seat._id,
                seatNumber: seat.seatNumber,
                sectionName: seat.sectionName,
                price: seat.price,
                status: 'active',
                issuedAt: new Date()
            });
            console.log(`‚úÖ Generated ticket for seat ${seat.sectionName} - ${seat.seatNumber}`);
        }
    } catch (error) {
        console.error('‚ùå Error generating tickets for seats:', error);
        throw error;
    }
};

// Helper function to generate tickets for ticket types
const generateTicketsForTickets = async (payment) => {
    try {
        console.log('üé´ Generating tickets for ticket types');
        
        for (const ticketInfo of payment.selectedTickets) {
            for (let i = 0; i < ticketInfo.quantity; i++) {
                const ticket = await Ticket.create({
                    userId: payment.userId,
                    eventId: payment.eventId,
                    bookingId: payment.bookingId,
                    paymentId: payment._id,
                    ticketType: 'regular',
                    ticketTypeId: ticketInfo.ticketTypeId,
                    ticketTypeName: ticketInfo.name,
                    price: ticketInfo.price,
                    status: 'active',
                    issuedAt: new Date()
                });
                console.log(`‚úÖ Generated ticket ${i + 1}/${ticketInfo.quantity} for ${ticketInfo.name}`);
            }
        }
    } catch (error) {
        console.error('‚ùå Error generating tickets for ticket types:', error);
        throw error;
    }
};

// Helper function to release seats and tickets
const releaseSeatsAndTickets = async (payment) => {
    try {
        console.log('üîÑ Releasing seats and tickets');
        
        // Release seats
        if (payment.selectedSeats) {
            for (const seat of payment.selectedSeats) {
                await Ticket.findByIdAndUpdate(seat._id, {
                    status: 'available',
                    userId: null,
                    bookingId: null,
                    paymentId: null
                });
                console.log(`üîÑ Released seat ${seat.sectionName} - ${seat.seatNumber}`);
            }
        }

        // Release ticket quantities
        if (payment.selectedTickets) {
            for (const ticketInfo of payment.selectedTickets) {
                const ticketType = await TicketType.findById(ticketInfo.ticketTypeId);
                if (ticketType) {
                    ticketType.quantity += ticketInfo.quantity;
                    await ticketType.save();
                    console.log(`üîÑ Released ${ticketInfo.quantity} tickets for ${ticketInfo.name}`);
                }
            }
        }
    } catch (error) {
        console.error('‚ùå Error releasing seats and tickets:', error);
        throw error;
    }
};

module.exports = {
    createPaymentUrl,
    vnpayCallback,
    createPOSPayment,
    handlePayOSReturn,
    handlePayOSWebhook,
    getPaymentMethods,
    getPaymentHistory,
    getPaymentDetail,
    getPOSPayments,
    confirmPOSPayment,
    cancelPOSPayment
}; 