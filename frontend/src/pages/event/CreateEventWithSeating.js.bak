import React, { useState, useEffect, useRef } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import axios from 'axios';
import { toast } from 'react-toastify';
import ImageUpload from '../../components/event/ImageUpload';
import SeatingPreview from '../../components/seating/SeatingPreview';
import InteractiveSeatingDesigner from '../../components/seating/InteractiveSeatingDesigner';
import './CreateEvent.css';
import { uploadImage } from '../../services/api';

// Th√™m styles inline ƒë·ªÉ ƒë·∫£m b·∫£o form hi·ªÉn th·ªã ƒë√∫ng
const styles = {
  container: {
    padding: '20px',
    maxWidth: '1200px',
    margin: '0 auto',
    backgroundColor: '#fff',
    borderRadius: '8px',
    boxShadow: '0 2px 10px rgba(0,0,0,0.1)'
  },
  header: {
    marginBottom: '20px',
    textAlign: 'center'
  },
  formSection: {
    marginBottom: '30px',
    padding: '20px',
    backgroundColor: '#f9fafb',
    borderRadius: '8px'
  },
  formGroup: {
    marginBottom: '15px'
  },
  label: {
    display: 'block',
    marginBottom: '5px',
    fontWeight: '500'
  },
  input: {
    width: '100%',
    padding: '10px',
    border: '1px solid #d1d5db',
    borderRadius: '4px',
    fontSize: '16px'
  },
  button: {
    padding: '10px 20px',
    backgroundColor: '#3b82f6',
    color: 'white',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer',
    fontSize: '16px'
  },
  stepActions: {
    display: 'flex',
    justifyContent: 'space-between',
    marginTop: '20px'
  }
};

// Venue templates v·ªõi layout th√¥ng minh
const VENUE_TEMPLATES = {
  stadium: {
    name: 'S√¢n v·∫≠n ƒë·ªông',
    description: '3 khu VIP ph√≠a tr∆∞·ªõc, c√°c khu kh√°c xung quanh',
    defaultSections: 8,
    defaultSeats: 300,
    layoutType: 'stadium',
    ticketTypeTemplates: [
      { name: 'VIP Tier 1', price: 800000, description: 'H√†ng gh·∫ø ƒë·∫ßu, view t·ªët nh·∫•t', percentage: 15, color: '#8B5CF6' },
      { name: 'VIP Tier 2', price: 600000, description: 'Khu VIP ph√≠a sau', percentage: 20, color: '#3B82F6' },
      { name: 'Th∆∞·ªùng A', price: 400000, description: 'Khu kh√°n ƒë√†i ch√≠nh', percentage: 35, color: '#10B981' },
      { name: 'Th∆∞·ªùng B', price: 250000, description: 'Khu kh√°n ƒë√†i ph·ª•', percentage: 30, color: '#F97316' }
    ],
    stageSize: { width: 200, height: 60 }
  },
  theater: {
    name: 'Nh√† h√°t / H·ªôi tr∆∞·ªùng',
    description: 'Layout truy·ªÅn th·ªëng v·ªõi gh·∫ø s·∫Øp x·∫øp theo h√†ng',
    defaultSections: 6,
    defaultSeats: 200,
    layoutType: 'theater',
    ticketTypeTemplates: [
      { name: 'VIP', price: 500000, description: 'Gh·∫ø h·∫°ng sang ph√≠a tr∆∞·ªõc', percentage: 30, color: '#8B5CF6' },
      { name: 'Th∆∞·ªùng', price: 300000, description: 'Gh·∫ø th√¥ng th∆∞·ªùng', percentage: 70, color: '#3B82F6' }
    ],
    stageSize: { width: 200, height: 60 }
  },
  concert: {
    name: 'Concert Hall',
    description: 'S√¢n kh·∫•u trung t√¢m v·ªõi khu VIP g·∫ßn s√¢n kh·∫•u',
    defaultSections: 10,
    defaultSeats: 500,
    layoutType: 'concert',
    ticketTypeTemplates: [
      { name: 'Golden Circle', price: 1500000, description: 'G·∫ßn s√¢n kh·∫•u nh·∫•t', percentage: 10, color: '#F59E0B' },
      { name: 'VIP', price: 800000, description: 'Khu VIP v·ªõi d·ªãch v·ª• ƒë·∫∑c bi·ªát', percentage: 20, color: '#8B5CF6' },
      { name: 'Th∆∞·ªùng A', price: 500000, description: 'Khu kh√°n ƒë√†i ch√≠nh', percentage: 40, color: '#3B82F6' },
      { name: 'Th∆∞·ªùng B', price: 300000, description: 'Khu kh√°n ƒë√†i xa', percentage: 30, color: '#10B981' }
    ],
    stageSize: { width: 200, height: 60 }
  },
  outdoor: {
    name: 'S·ª± ki·ªán ngo√†i tr·ªùi',
    description: 'Kh√¥ng gian m·ªü v·ªõi c√°c khu v·ª±c linh ho·∫°t',
    defaultSections: 5,
    defaultSeats: 150,
    layoutType: 'outdoor',
    ticketTypeTemplates: [
      { name: 'VIP Front', price: 600000, description: 'Khu v·ª±c ph√≠a tr∆∞·ªõc', percentage: 25, color: '#8B5CF6' },
      { name: 'General', price: 350000, description: 'Khu v·ª±c chung', percentage: 75, color: '#3B82F6' }
    ],
    stageSize: { width: 200, height: 60 }
  },
  footballStadium: {
    name: 'S√¢n v·∫≠n ƒë·ªông b√≥ng ƒë√°',
    description: 'Layout s√¢n b√≥ng chuy√™n nghi·ªáp v·ªõi VIP t·∫ßng tr√™n, kh√°n ƒë√†i ch√≠nh v√† khu g√≥c',
    defaultSections: 12,
    defaultSeats: 1000,
    layoutType: 'footballStadium',
    ticketTypeTemplates: [
      { name: 'VIP Box', price: 2500000, description: 'H·ªôp VIP t·∫ßng tr√™n (DB1, DB2, DC1, DC2)', percentage: 20, color: '#DC2626' },
      { name: 'Premium', price: 1500000, description: 'Kh√°n ƒë√†i cao c·∫•p g·∫ßn s√¢n (DA1, DA2)', percentage: 20, color: '#7C3AED' },
      { name: 'Kh√°n ƒë√†i Ch√≠nh', price: 1000000, description: 'Kh√°n ƒë√†i ch√≠nh hai b√™n (DA3, DA4)', percentage: 30, color: '#2563EB' },
      { name: 'Kh√°n ƒë√†i G√≥c', price: 700000, description: 'Khu v·ª±c g√≥c s√¢n (KD_A, KD_B, KD_C)', percentage: 20, color: '#059669' },
      { name: 'FOH', price: 400000, description: 'Khu v·ª±c FOH v√† c√°c khu xa', percentage: 10, color: '#D97706' }
    ],
    stageSize: { width: 400, height: 200 }
  },
  basketballArena: {
    name: 'S√¢n b√≥ng r·ªï',
    description: 'Arena b√≥ng r·ªï v·ªõi kh√°n ƒë√†i bao quanh s√¢n',
    defaultSections: 8,
    defaultSeats: 600,
    layoutType: 'basketballArena',
    ticketTypeTemplates: [
      { name: 'Courtside', price: 1500000, description: 'Gh·∫ø s√°t s√¢n v·ªõi tr·∫£i nghi·ªám t·ªët nh·∫•t', percentage: 10, color: '#DC2626' },
      { name: 'Lower Bowl', price: 800000, description: 'T·∫ßng d∆∞·ªõi g·∫ßn s√¢n', percentage: 30, color: '#7C3AED' },
      { name: 'Club Level', price: 600000, description: 'T·∫ßng club v·ªõi ti·ªán √≠ch', percentage: 25, color: '#2563EB' },
      { name: 'Upper Bowl', price: 350000, description: 'T·∫ßng tr√™n v·ªõi gi√° h·ª£p l√Ω', percentage: 35, color: '#059669' }
    ],
    stageSize: { width: 350, height: 180 }
  }
};

// Define constants for seating layout
const CANVAS_WIDTH = 1200;
const CANVAS_HEIGHT = 1000;

// Stage dimensions based on venue type
const STAGE_DIMENSIONS = {
  footballStadium: { width: 320, height: 220, x: 440, y: 50 }, // S√¢n b√≥ng ƒë√° - l·ªõn nh·∫•t
  basketballArena: { width: 280, height: 180, x: 460, y: 70 }, // S√¢n b√≥ng r·ªï - trung b√¨nh
  theater: { width: 240, height: 80, x: 480, y: 50 }, // Nh√† h√°t - nh·ªè, r·ªông
  concert: { width: 220, height: 80, x: 490, y: 50 }, // Concert - nh·ªè, r·ªông
  conference: { width: 200, height: 60, x: 500, y: 50 }, // H·ªôi ngh·ªã - nh·ªè nh·∫•t
  outdoor: { width: 250, height: 80, x: 475, y: 50 }, // Ngo√†i tr·ªùi - trung b√¨nh
  custom: { width: 200, height: 60, x: 500, y: 50 }, // T√πy ch·ªânh - m·∫∑c ƒë·ªãnh
};

// Create initial stage based on venue type
const getInitialStage = (venueType) => {
  const dimensions = STAGE_DIMENSIONS[venueType] || STAGE_DIMENSIONS.custom;
  return {
    ...dimensions,
    type: venueType === 'footballStadium' ? 'footballField' : 
          venueType === 'basketballArena' ? 'basketballCourt' : 'stage'
  };
};

// Th√™m danh s√°ch c√°c lo·∫°i v·∫≠t th·ªÉ ph·ª• tr·ª£
const VENUE_OBJECT_TYPES = [
  { value: 'wc', label: 'Nh√† v·ªá sinh', color: '#3B82F6' },
  { value: 'entrance', label: 'L·ªëi v√†o', color: '#10B981' },
  { value: 'exit', label: 'L·ªëi ra', color: '#EF4444' },
  { value: 'bar', label: 'Qu·∫ßy n∆∞·ªõc', color: '#F59E0B' },
  { value: 'food', label: 'Qu·∫ßy th·ª©c ƒÉn', color: '#8B5CF6' },
  { value: 'info', label: 'Qu·∫ßy th√¥ng tin', color: '#06B6D4' },
  { value: 'merch', label: 'Qu·∫ßy b√°n h√†ng l∆∞u ni·ªám', color: '#F472B6' },
  { value: 'medical', label: 'Tr·∫°m y t·∫ø', color: '#DC2626' },
  { value: 'security', label: 'B·∫£o v·ªá', color: '#4B5563' },
  { value: 'elevator', label: 'Thang m√°y', color: '#6366F1' },
  { value: 'stairs', label: 'C·∫ßu thang', color: '#9333EA' },
  { value: 'vip', label: 'Khu v·ª±c VIP', color: '#FFD700' },
  { value: 'photo', label: 'ƒêi·ªÉm ch·ª•p ·∫£nh', color: '#14B8A6' },
  { value: 'charging', label: 'Tr·∫°m s·∫°c', color: '#F97316' }
];

// H√†m t·∫°o m√†u ng·∫´u nhi√™n cho c√°c lo·∫°i v√©
const getRandomColor = () => {
  const colors = [
    '#3B82F6', // Blue
    '#8B5CF6', // Purple
    '#10B981', // Green
    '#F59E0B', // Orange
    '#EF4444', // Red
    '#06B6D4', // Cyan
    '#84CC16', // Lime
    '#F472B6', // Pink
    '#6366F1', // Indigo
    '#EC4899', // Pink
    '#14B8A6', // Teal
    '#9333EA'  // Purple
  ];
  
  return colors[Math.floor(Math.random() * colors.length)];
};

const CreateEventWithSeating = () => {
  console.log("Rendering CreateEventWithSeating component...");
  const navigate = useNavigate();
  const location = useLocation();
  const initialEventData = location.state?.eventData || {
    title: '',
    description: '',
    startDate: '',
    endDate: '',
    location: {
      venueName: '',
      address: ''
    },
    images: {
      logo: '',
      banner: ''
    }
  };
  
  const [eventData, setEventData] = useState(initialEventData);
  const [loading, setLoading] = useState(false);
  const [message, setMessage] = useState('');
  const [currentStep, setCurrentStep] = useState(1);
  const [designMode, setDesignMode] = useState('custom'); // Lu√¥n l√† 'custom'
  const [customSeatingMap, setCustomSeatingMap] = useState({
    layoutType: 'custom',
    sections: [],
    stage: { x: 400, y: 50, width: 200, height: 60 },
    venueObjects: [] // Ensure venue objects array is initialized
  });
  const [isEditingTicketTypesManually, setIsEditingTicketTypesManually] = useState(false);
  
  const [seatOptions, setSeatOptions] = useState({
    venueType: 'custom',
    hasSeatingChart: true,
    ticketTypes: [
      { name: 'Standard', price: 0, color: '#3B82F6' }
    ]
  });

  const [ticketTypes, setTicketTypes] = useState([
    {
      name: 'VIP',
      price: 500000,
      description: 'V√© h·∫°ng VIP v·ªõi v·ªã tr√≠ t·ªët nh·∫•t',
      quantity: 60,
      color: '#8B5CF6'
    },
    {
      name: 'Th∆∞·ªùng',
      price: 300000,
      description: 'V√© th∆∞·ªùng v·ªõi gi√° h·ª£p l√Ω',
      quantity: 140,
      color: '#3B82F6'
    }
  ]);

  // Initialize venue objects if they don't exist (with proper dependencies)
  useEffect(() => {
    if (!customSeatingMap.venueObjects) {
      console.log('üèóÔ∏è Initializing venue objects array');
      setCustomSeatingMap(prev => ({
        ...prev,
        venueObjects: []
      }));
    }
  }, []); // Run only once on component mount

  // Smart seat distribution when changing total seats - preserve colors
  const handleSeatChange = (newTotalSeats) => {
    if (seatOptions.venueType) {
      const template = VENUE_TEMPLATES[seatOptions.venueType];
      const updatedTicketTypes = ticketTypes.map(tt => {
        const templateTT = template.ticketTypeTemplates.find(t => t.name === tt.name);
        const percentage = templateTT ? templateTT.percentage : (tt.quantity / seatOptions.totalSeats * 100);
        return {
          ...tt,
          quantity: Math.floor(newTotalSeats * percentage / 100),
          color: tt.color || templateTT?.color || '#6B7280' // Preserve existing color
        };
      });
      setTicketTypes(updatedTicketTypes);
    }
    
    setSeatOptions(prev => ({ ...prev, totalSeats: parseInt(newTotalSeats) }));
    generatePreviewMap(newTotalSeats, seatOptions.totalSections, seatOptions.venueType);
  };

  // Generate preview seating map
  const generatePreviewMap = async (
    totalSeats = seatOptions.totalSeats, 
    totalSections = seatOptions.totalSections, 
    venueType = seatOptions.venueType,
    stageSize
  ) => {
    try {
      console.log('üîÑ Generating preview...', { totalSeats, totalSections, venueType, stageSize });
      
      const response = await axios.post('https://eventbackendacr-c4dhdsbhfug2hkb2.australiacentral-01.azurewebsites.net///events/preview-seating', {
        seatOptions: { totalSeats, totalSections, venueType },
        ticketTypes: ticketTypes.map(tt => ({ ...tt, _id: `temp_${tt.name}` }))
      }, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });
      
      if (response.data.success) {
        console.log('‚úÖ Preview generated successfully');
        setCustomSeatingMap(response.data.data);
      }
    } catch (error) {
      console.error('‚ùå Error generating preview:', error);
      
      // Better fallback with mock sections
      const mockSections = [];
      const seatsPerSection = Math.floor(totalSeats / totalSections);
      
      for (let i = 0; i < Math.min(totalSections, 3); i++) {
        mockSections.push({
          name: `Khu ${String.fromCharCode(65 + i)}`,
          capacity: seatsPerSection,
          x: 100 + i * 200,
          y: 200 + i * 50,
          width: 150,
          height: 100,
          rows: [{
            rowNumber: 1,
            rowLetter: 'A',
            seats: Array.from({ length: Math.min(seatsPerSection, 10) }, (_, j) => ({
              seatNumber: j + 1,
              x: 100 + i * 200 + j * 15,
              y: 200 + i * 50,
              status: 'available'
            }))
          }]
        });
      }
      
      // K√≠ch th∆∞·ªõc stage t√πy ch·ªânh theo lo·∫°i s√¢n
      const defaultStageSize = {
        width: venueType === 'footballStadium' ? 400 :
               venueType === 'basketballArena' ? 350 :
               200,
        height: venueType === 'footballStadium' ? 200 :
                venueType === 'basketballArena' ? 180 :
                60
      };
      
      const stageDimensions = stageSize || defaultStageSize;
      
      setCustomSeatingMap({
        layoutType: venueType,
        sections: mockSections,
        stage: { 
          x: 400 - (stageDimensions.width / 2), // CƒÉn gi·ªØa theo chi·ªÅu ngang
          y: 20, 
          width: stageDimensions.width, 
          height: stageDimensions.height 
        }
      });
    }
  };

  const handleImageUpload = async (e, imageType) => {
    const file = e.target.files[0];
    if (file) {
      try {
        console.log(`üñºÔ∏è B·∫Øt ƒë·∫ßu upload h√¨nh ·∫£nh ${imageType}...`);
        // Upload to server using helper function
        const result = await uploadImage(file, imageType);
        
        if (result.success) {
          console.log(`‚úÖ Upload ${imageType} th√†nh c√¥ng:`, result.url);
          // Hi·ªÉn th·ªã toast th√†nh c√¥ng thay v√¨ alert
          toast.success(`Upload ${imageType} th√†nh c√¥ng!`, {
            position: "top-right",
            autoClose: 3000,
            hideProgressBar: false,
            closeOnClick: true,
            pauseOnHover: true,
            draggable: true,
            progress: undefined,
          });
          
          // C·∫≠p nh·∫≠t state v·ªõi URL h√¨nh ·∫£nh ƒë√£ upload
          setEventData(prevState => {
            console.log(`üîÑ C·∫≠p nh·∫≠t state.images.${imageType} v·ªõi URL:`, result.url);
            return {
              ...prevState,
              images: {
                ...prevState.images,
                [imageType]: result.url
              }
            };
          });
          
          return result.url;
        } else {
          console.error(`‚ùå L·ªói upload ${imageType}:`, result.message);
          // Hi·ªÉn th·ªã toast l·ªói thay v√¨ alert
          toast.error(`L·ªói upload ${imageType}: ${result.message}`, {
            position: "top-right",
            autoClose: 5000,
            hideProgressBar: false,
            closeOnClick: true,
            pauseOnHover: true,
            draggable: true,
            progress: undefined,
          });
        }
      } catch (error) {
        console.error('Upload error:', error);
        if (error.response?.status === 401) {
          // Hi·ªÉn th·ªã toast l·ªói x√°c th·ª±c
          toast.error(`L·ªói x√°c th·ª±c, vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i ƒë·ªÉ upload ${imageType}`, {
            position: "top-right",
            autoClose: 5000,
            hideProgressBar: false,
            closeOnClick: true,
            pauseOnHover: true,
            draggable: true,
            progress: undefined,
          });
        } else {
          // Hi·ªÉn th·ªã toast l·ªói kh√°c
          toast.error(`L·ªói upload ${imageType}: ${error.message}`, {
            position: "top-right",
            autoClose: 5000,
            hideProgressBar: false,
            closeOnClick: true,
            pauseOnHover: true,
            draggable: true,
            progress: undefined,
          });
        }
      }
    }
    return null;
  };

  const handleSeatOptionsChange = (e) => {
    const { name, value } = e.target;
    if (name === 'totalSeats') {
      handleSeatChange(value);
    } else {
      const newSeatOptions = { ...seatOptions, [name]: parseInt(value) };
      setSeatOptions(newSeatOptions);
      // Generate preview khi thay ƒë·ªïi venueType ho·∫∑c totalSections
      setTimeout(() => {
        generatePreviewMap(newSeatOptions.totalSeats, newSeatOptions.totalSections, newSeatOptions.venueType);
      }, 300);
    }
  };

  const handleTicketTypeChange = (index, field, value) => {
    // Mark as manually editing when user changes ticket types
    console.log(`üéõÔ∏è User manually changed ticket type [${index}].${field} = ${value}`);
    console.log(`üéõÔ∏è Before: isEditingTicketTypesManually = ${isEditingTicketTypesManually}`);
    setIsEditingTicketTypesManually(true);
    console.log(`üéõÔ∏è After: isEditingTicketTypesManually = true`);
    
    const updatedTicketTypes = [...ticketTypes];
    
    if (field === 'price' || field === 'quantity') {
      updatedTicketTypes[index][field] = parseInt(value) || 0;
    } else {
      updatedTicketTypes[index][field] = value;
    }
    
    setTicketTypes(updatedTicketTypes);
    console.log(`üéõÔ∏è Updated ticket types:`, updatedTicketTypes);
    
    // Log m√†u s·∫Øc change ƒë·ªÉ debug
    if (field === 'color') {
      console.log(`üé® Color changed for ${updatedTicketTypes[index].name}: ${value}`);
    }
  };

  const addTicketType = (e) => {
    // N·∫øu ƒë∆∞·ª£c g·ªçi t·ª´ m·ªôt s·ª± ki·ªán, ngƒÉn ch·∫∑n h√†nh vi m·∫∑c ƒë·ªãnh
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    
    // Mark as manually editing when user adds ticket type
    setIsEditingTicketTypesManually(true);
    
    // Generate m√†u ng·∫´u nhi√™n cho ticket type m·ªõi
    const colors = ['#8B5CF6', '#3B82F6', '#10B981', '#F97316', '#EF4444', '#F59E0B', '#06B6D4', '#84CC16'];
    const randomColor = colors[Math.floor(Math.random() * colors.length)];
    
    setTicketTypes([...ticketTypes, {
      name: '',
      price: 0,
      description: '',
      quantity: 0,
      color: randomColor
    }]);
    
    console.log('Added new ticket type, prevented form submission');
  };

  const removeTicketType = (index, e) => {
    // NgƒÉn ch·∫∑n s·ª± ki·ªán m·∫∑c ƒë·ªãnh n·∫øu ƒë∆∞·ª£c g·ªçi t·ª´ m·ªôt s·ª± ki·ªán
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    
    if (ticketTypes.length > 1) {
      // Mark as manually editing when user removes ticket type
      setIsEditingTicketTypesManually(true);
      setTicketTypes(ticketTypes.filter((_, i) => i !== index));
      console.log('Removed ticket type at index', index, 'prevented form submission');
    }
  };

  const nextStep = () => {
    // Validation cho step 1 (th√¥ng tin c∆° b·∫£n)
    if (currentStep === 1) {
      if (!eventData.startDate || !eventData.endDate) {
        setMessage('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß Ng√†y b·∫Øt ƒë·∫ßu v√† Ng√†y k·∫øt th√∫c v·ªõi gi·ªù c·ª• th·ªÉ.');
        return;
      }
      
      const startDate = new Date(eventData.startDate);
      const endDate = new Date(eventData.endDate);
      const now = new Date();
      
      // Ki·ªÉm tra th·ªùi gian trong t∆∞∆°ng lai
      if (startDate <= now) {
        setMessage('Ng√†y b·∫Øt ƒë·∫ßu ph·∫£i trong t∆∞∆°ng lai (√≠t nh·∫•t 1 gi·ªù t·ª´ b√¢y gi·ªù).');
        return;
      }
      
      if (startDate >= endDate) {
        setMessage('Ng√†y k·∫øt th√∫c ph·∫£i sau ng√†y b·∫Øt ƒë·∫ßu.');
        return;
      }
      
      // Ki·ªÉm tra th·ªùi l∆∞·ª£ng t·ªëi thi·ªÉu (√≠t nh·∫•t 30 ph√∫t)
      const diffMs = endDate - startDate;
      if (diffMs < 30 * 60 * 1000) {
        setMessage('S·ª± ki·ªán ph·∫£i c√≥ th·ªùi l∆∞·ª£ng √≠t nh·∫•t 30 ph√∫t.');
        return;
      }
      
      // Clear message n·∫øu validation pass
      setMessage('');
    }
    
    if (currentStep < 3) setCurrentStep(currentStep + 1);
  };

  const prevStep = () => {
    if (currentStep > 1) setCurrentStep(currentStep - 1);
  };

  // Handle event data change
  const handleEventDataChange = (e) => {
    const { name, value } = e.target;
    
    // Handle nested properties like location.venueName
    if (name.includes('.')) {
      const [parent, child] = name.split('.');
      setEventData(prev => ({
        ...prev,
        [parent]: {
          ...prev[parent],
          [child]: value
        }
      }));
    } else {
      setEventData(prev => ({
        ...prev,
        [name]: value
      }));
    }
  };

  // Improved seat counting function that checks if sections have any seats
  const countTotalSeats = () => {
    let totalSeats = 0;
    
    // Check if seatingMap and sections exist
    if (!customSeatingMap || !customSeatingMap.sections) {
      return 0;
    }
    
    // Count seats in each section
    customSeatingMap.sections.forEach(section => {
      if (section.rows) {
        section.rows.forEach(row => {
          if (row.seats && Array.isArray(row.seats)) {
            totalSeats += row.seats.length;
          }
        });
      }
    });
    
    console.log(`üìä countTotalSeats: Found ${totalSeats} seats in ${customSeatingMap.sections.length} sections`);
    return totalSeats;
  };

  // Update useEffect to also set city if it's missing
  useEffect(() => {
    // Set default organizers and city if not already set
    const updates = {};
    
    if (!eventData.organizers) {
      updates.organizers = 'T·ªï ch·ª©c b·ªüi ' + (localStorage.getItem('username') || 'Event Hub');
    }
    
    if (eventData.location && !eventData.location.city) {
      updates.location = {
        ...eventData.location,
        city: 'H·ªì Ch√≠ Minh' // Default city
      };
    }
    
    if (Object.keys(updates).length > 0) {
      setEventData(prev => ({
        ...prev,
        ...updates
      }));
    }
  }, [eventData]);

  // Define steps for the form
  const steps = [
    { id: 1, name: 'Th√¥ng tin' },
    { id: 2, name: 'C·∫•u h√¨nh' },
    { id: 3, name: 'X√°c nh·∫≠n' },
  ];

  // Update the event payload preparation in handleSubmit
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // Ch·ªâ submit khi ·ªü b∆∞·ªõc cu·ªëi c√πng (b∆∞·ªõc x√°c nh·∫≠n)
    if (currentStep !== 3) {
      setCurrentStep(prevStep => prevStep + 1);
      console.log('Ch∆∞a ƒë·∫øn b∆∞·ªõc cu·ªëi c√πng, kh√¥ng submit form');
      return;
    }
    
    try {
      setLoading(true);
      console.log('üöÄ Chu·∫©n b·ªã g·ª≠i d·ªØ li·ªáu s·ª± ki·ªán...');
      
      // Preserve the exact seating map layout with all coordinates and properties
      // Make sure seatingMap is complete with all necessary components
      const processedSeatingMap = {
        ...customSeatingMap,
        layoutType: customSeatingMap.layoutType || 'custom',
        // Ensure stage is included with exact coordinates
        stage: customSeatingMap.stage || {
          x: 400,
          y: 50,
          width: 300,
          height: 60,
          centerX: 400,
          centerY: 50
        },
        // Ensure venue objects are included
        venueObjects: Array.isArray(customSeatingMap.venueObjects) ? customSeatingMap.venueObjects : []
      };
      
      // Verify that sections have proper coordinates
      if (processedSeatingMap.sections && processedSeatingMap.sections.length > 0) {
        processedSeatingMap.sections = processedSeatingMap.sections.map(section => {
          // Ensure each section is preserved with original coordinates
          return {
            ...section,
            rows: section.rows.map(row => {
              // Ensure each row has properly formatted seats with coordinates
              return {
                ...row,
                seats: row.seats.map(seat => {
                  // Ensure each seat has x,y coordinates and proper number format
                  return {
                    ...seat,
                    number: seat.number ? seat.number.toString() : "1",
                    x: typeof seat.x === 'number' ? seat.x : 0,
                    y: typeof seat.y === 'number' ? seat.y : 0,
                    status: seat.status || 'available'
                  };
                })
              };
            })
          };
        });
      }
      
      console.log('üöÄ G·ª≠i d·ªØ li·ªáu s·ª± ki·ªán:', {
        ...eventData,
        seatingMap: processedSeatingMap,
        ticketTypes
      });
      
      const apiUrl = `${process.env.REACT_APP_API_URL || 'https://eventbackendacr-c4dhdsbhfug2hkb2.australiacentral-01.azurewebsites.net//'}/events/create-with-seating`;
      console.log('üîß Using API URL:', apiUrl);
      
      const response = await axios.post(apiUrl, {
        ...eventData,
        seatingMap: processedSeatingMap,
        ticketTypes
      }, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
          'Content-Type': 'application/json'
        }
      });
      
      console.log('‚úÖ T·∫°o s·ª± ki·ªán th√†nh c√¥ng:', response.data);
      toast.success('T·∫°o s·ª± ki·ªán th√†nh c√¥ng!');
      
      // ƒê·∫£m b·∫£o th·ªùi gian ƒë·ªÉ hi·ªÉn th·ªã toast tr∆∞·ªõc khi chuy·ªÉn trang
      setTimeout(() => {
        // Redirect to my events page instead of event detail page
        navigate('/my-events', { replace: true });
      }, 800);
      
    } catch (error) {
      console.error('‚ùå L·ªói khi t·∫°o s·ª± ki·ªán:', error);
      console.log('üì° Server responded with error:', error.response?.status);
      console.log('üì° Error data:', error.response?.data);
      setMessage(`L·ªói: ${error.response?.data?.message || 'Kh√¥ng th·ªÉ t·∫°o s·ª± ki·ªán. Vui l√≤ng th·ª≠ l·∫°i sau.'}`);
      toast.error(`L·ªói: ${error.response?.data?.message || 'Kh√¥ng th·ªÉ t·∫°o s·ª± ki·ªán'}`);
    } finally {
      setLoading(false);
    }
  };

  // Improved addVenueObject function with better positioning
  const addVenueObject = (type, e) => {
    // NgƒÉn ch·∫∑n form submit n·∫øu ƒë∆∞·ª£c g·ªçi t·ª´ s·ª± ki·ªán
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    
    // S·ª≠ d·ª•ng t·ªça ƒë·ªô m·∫∑c ƒë·ªãnh ho·∫∑c v·ªã tr√≠ khung nh√¨n n·∫øu kh√¥ng c√≥ t·ªça ƒë·ªô ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh
    const venueObjectTypes = {
      entrance: { name: 'L·ªëi v√†o', color: '#10B981', width: 60, height: 30 },
      exit: { name: 'L·ªëi ra', color: '#EF4444', width: 60, height: 30 },
      restroom: { name: 'WC', color: '#3B82F6', width: 40, height: 40 },
      food: { name: 'Th·ª©c ƒÉn', color: '#8B5CF6', width: 40, height: 40 },
      drinks: { name: 'ƒê·ªì u·ªëng', color: '#F59E0B', width: 40, height: 40 },
      merchandise: { name: 'B√°n h√†ng', color: '#F472B6', width: 40, height: 40 },
      info: { name: 'Th√¥ng tin', color: '#06B6D4', width: 40, height: 40 },
      security: { name: 'An ninh', color: '#4B5563', width: 40, height: 40 },
      accessible: { name: 'H·ªó tr·ª£', color: '#84CC16', width: 40, height: 40 },
      firstaid: { name: 'S∆° c·ª©u', color: '#DC2626', width: 40, height: 40 },
      elevator: { name: 'Thang m√°y', color: '#9333EA', width: 40, height: 40 },
      stairs: { name: 'C·∫ßu thang', color: '#2563EB', width: 40, height: 40 },
      column: { name: 'C·ªôt', color: '#6B7280', width: 20, height: 20 },
      camera: { name: 'Camera', color: '#1F2937', width: 30, height: 30 }
    };
    
    const objectInfo = venueObjectTypes[type] || venueObjectTypes.info;
    
    // T√≠nh v·ªã tr√≠ m·∫∑c ƒë·ªãnh - offset t∆∞∆°ng ƒë·ªëi so v·ªõi s√¢n kh·∫•u
    const stage = customSeatingMap.stage || { x: 400, y: 50, width: 200, height: 60 };
    
    // T·∫°o m·ªôt ƒë·ªëi t∆∞·ª£ng ID duy nh·∫•t cho m·ªói lo·∫°i v·∫≠t th·ªÉ
    const timestamp = Date.now();
    const uniqueID = `${type}-${timestamp}-${Math.floor(Math.random() * 1000)}`;
    
    // T√≠nh v·ªã tr√≠ m·∫∑c ƒë·ªãnh d·ª±a v√†o lo·∫°i ƒë·ªëi t∆∞·ª£ng
    let x, y;
    
    // T√≠nh to√°n v·ªã tr√≠ th√≠ch h·ª£p d·ª±a tr√™n lo·∫°i v√† s·ªë l∆∞·ª£ng ƒë√£ c√≥
    const existingObjects = customSeatingMap.venueObjects || [];
    const sameTypeCount = existingObjects.filter(obj => obj.objectType === type).length;
    
    // V·ªã tr√≠ m·∫∑c ƒë·ªãnh d·ª±a tr√™n lo·∫°i
    switch (type) {
      case 'entrance':
        x = stage.x - 170 - sameTypeCount * 70;
        y = stage.y + 450;
        break;
      case 'exit':
        x = stage.x + stage.width + 100 + sameTypeCount * 70;
        y = stage.y + 450;
        break;
      case 'restroom':
        x = stage.x - 170 - sameTypeCount * 50;
        y = stage.y + 350;
        break;
      case 'food':
      case 'drinks':
        x = stage.x + stage.width + 100 + sameTypeCount * 50;
        y = stage.y + 350 - (type === 'drinks' ? 50 : 0);
        break;
      default:
        // ƒê·∫∑t c√°c v·∫≠t th·ªÉ kh√°c ·ªü v·ªã tr√≠ ng·∫´u nhi√™n xung quanh s√¢n kh·∫•u
        const angle = Math.random() * Math.PI; // G√≥c ng·∫´u nhi√™n t·ª´ 0 ƒë·∫øn PI
        const distance = 300 + Math.random() * 150; // Kho·∫£ng c√°ch t·ª´ 300 ƒë·∫øn 450px
        const centerX = stage.x + stage.width / 2;
        const centerY = stage.y + stage.height / 2;
        x = centerX + Math.cos(angle) * distance;
        y = centerY + Math.sin(angle) * distance;
    }
    
    // T·∫°o ƒë·ªëi t∆∞·ª£ng m·ªõi
    const newObject = {
      id: uniqueID,
      objectType: type,
      type: type,
      label: objectInfo.name,
      x: x,
      y: y,
      width: objectInfo.width,
      height: objectInfo.height,
      color: objectInfo.color
    };
    
    // C·∫≠p nh·∫≠t seatingMap v·ªõi ƒë·ªëi t∆∞·ª£ng m·ªõi
    const updatedObjects = [...(customSeatingMap.venueObjects || []), newObject];
    
    // C·∫≠p nh·∫≠t state
    setCustomSeatingMap(prev => {
      return {
        ...prev,
        venueObjects: updatedObjects
      };
    });
    
    console.log(`Added venue object: ${type} at (${x}, ${y}), prevented form submission`);
    
    return newObject;
  };
  
  // Th√™m h√†m ƒë·ªÉ x√≥a v·∫≠t th·ªÉ ph·ª• tr·ª£
  const removeVenueObject = (index) => {
    setCustomSeatingMap(prev => ({
      ...prev,
      venueObjects: (prev.venueObjects || []).filter((_, i) => i !== index)
    }));
    
    toast.info('ƒê√£ x√≥a v·∫≠t th·ªÉ');
  };
  
  // Th√™m h√†m ƒë·ªÉ c·∫≠p nh·∫≠t v·∫≠t th·ªÉ ph·ª• tr·ª£
  const updateVenueObject = (index, field, value) => {
    setCustomSeatingMap(prev => {
      const updatedObjects = [...(prev.venueObjects || [])];
      if (updatedObjects[index]) {
        updatedObjects[index] = {
          ...updatedObjects[index],
          [field]: value
        };
      }
      return {
        ...prev,
        venueObjects: updatedObjects
      };
    });
  };

  // S·ª≠a h√†m handleCustomSeatingMapChange ƒë·ªÉ x·ª≠ l√Ω venueObjects v√† ƒë·∫øm gh·∫ø ch√≠nh x√°c
  const handleCustomSeatingMapChange = (newSeatingMap) => {
    // Tr√°nh c·∫≠p nh·∫≠t kh√¥ng c·∫ßn thi·∫øt ƒë·ªÉ ngƒÉn v√≤ng l·∫∑p v√¥ h·∫°n
    if (JSON.stringify(newSeatingMap) === JSON.stringify(customSeatingMap)) {
      return; // Kh√¥ng c√≥ thay ƒë·ªïi th·ª±c s·ª±, b·ªè qua c·∫≠p nh·∫≠t
    }
    
    // Gi·ªØ l·∫°i venueObjects t·ª´ state hi·ªán t·∫°i n·∫øu kh√¥ng ƒë∆∞·ª£c cung c·∫•p trong newSeatingMap
    const updatedSeatingMap = {
      ...newSeatingMap,
      venueObjects: newSeatingMap.venueObjects || customSeatingMap.venueObjects
    };
    
    console.log('üîÑ Updating seatingMap with venue objects:', updatedSeatingMap.venueObjects?.length || 0);
    
    // C·∫≠p nh·∫≠t state m·ªôt c√°ch an to√†n
    setCustomSeatingMap(updatedSeatingMap);
    
    // ƒê·∫øm s·ªë gh·∫ø trong t·∫•t c·∫£ c√°c sections
    const countSeats = () => {
      let totalSeats = 0;
      const sections = updatedSeatingMap.sections || [];
      
      sections.forEach(section => {
        if (section.rows) {
          section.rows.forEach(row => {
            totalSeats += (row.seats?.length || 0);
          });
        }
      });
      
      return totalSeats;
    };
    
    const totalSeatCount = countSeats();
    console.log(`üìä T·ªïng s·ªë gh·∫ø: ${totalSeatCount}, S·ªë khu v·ª±c: ${updatedSeatingMap.sections?.length || 0}`);
    
    // C·∫≠p nh·∫≠t seatOptions n·∫øu c·∫ßn
    if (totalSeatCount > 0 && seatOptions.totalSeats !== totalSeatCount) {
      setSeatOptions(prev => ({...prev, totalSeats: totalSeatCount}));
    }
    
    // Only auto-update ticket types if user hasn't manually edited them
    if (!isEditingTicketTypesManually) {
      const sections = updatedSeatingMap.sections || [];
      
      // Extract unique ticketTiers from sections
      const uniqueTicketTiers = [...new Set(sections.map(s => s.ticketTier).filter(Boolean))];
      
      if (uniqueTicketTiers.length > 0) {
        // Create ticket types based on unique tiers if they don't exist already
        const newTicketTypes = uniqueTicketTiers.map((tier, index) => {
          // Try to find existing ticket type with this ID
          const existingType = ticketTypes.find(tt => tt._id === tier);
          
          if (existingType) {
            // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng v√© d·ª±a tr√™n s·ªë gh·∫ø trong section
            let seatCount = 0;
            sections.forEach(section => {
              if (section.ticketTier === tier && section.rows) {
                section.rows.forEach(row => {
                  seatCount += (row.seats?.length || 0);
                });
              }
            });
            
            return {
              ...existingType,
              quantity: seatCount > 0 ? seatCount : existingType.quantity
            };
          }
          
          // T√≠nh s·ªë l∆∞·ª£ng v√© cho lo·∫°i v√© m·ªõi
          let seatCount = 0;
          sections.forEach(section => {
            if (section.ticketTier === tier && section.rows) {
              section.rows.forEach(row => {
                seatCount += (row.seats?.length || 0);
              });
            }
          });
          
          // Create new ticket type
          return {
            _id: tier,
            name: `Lo·∫°i v√© ${index + 1}`,
            price: (index + 1) * 100000,
            description: `M√¥ t·∫£ lo·∫°i v√© ${index + 1}`,
            quantity: seatCount,
            color: getRandomColor()
          };
        });
        
        setTicketTypes(newTicketTypes);
      }
    }
  };
  
  // Th√™m h√†m ngƒÉn ch·∫∑n s·ª± ki·ªán click lan truy·ªÅn t·ª´ c√°c n√∫t th√™m v·∫≠t th·ªÉ
  const handleVenueObjectButtonClick = (e, type) => {
    e.preventDefault(); // NgƒÉn form submit
    e.stopPropagation(); // NgƒÉn s·ª± ki·ªán lan truy·ªÅn
    addVenueObject(type, e);
  };

  // Auto-arrange sections to prevent overlapping
  const autoArrangeSections = (seatingMap) => {
    if (!seatingMap || !seatingMap.sections || seatingMap.sections.length === 0) {
      return seatingMap; // Nothing to arrange
    }

    // Clone to avoid mutation
    const clonedMap = JSON.parse(JSON.stringify(seatingMap));
    
    const isOverlapping = (rect1, rect2) => {
      // Th√™m margin ƒë·ªÉ ƒë·∫£m b·∫£o kho·∫£ng c√°ch an to√†n
      const margin = 25; // TƒÉng l√™n t·ª´ 15 ƒë·ªÉ ƒë·∫£m b·∫£o kho·∫£ng c√°ch l·ªõn h∆°n
      return rect1.x < rect2.x + rect2.width + margin &&
         rect1.x + rect1.width + margin > rect2.x &&
         rect1.y < rect2.y + rect2.height + margin &&
         rect1.y + rect1.height + margin > rect2.y;
    };
    
    const arrangeInGrid = (sections) => {
      // Calculate optimal spacing based on layout type
      const layoutType = clonedMap.layoutType || 'custom';
      
      // X√°c ƒë·ªãnh kho·∫£ng c√°ch gi·ªØa c√°c khu v·ª±c d·ª±a tr√™n lo·∫°i layout
      const spacingConfig = {
        footballStadium: {
          horizontalGap: 150,  // TƒÉng t·ª´ 100
          verticalGap: 120,    // TƒÉng t·ª´ 80
          stagePadding: 300,   // TƒÉng t·ª´ 250
          startX: 100,
          startY: 300,
          sectionPadding: 30   // TƒÉng t·ª´ 15
        },
        basketballArena: {
          horizontalGap: 120,  // TƒÉng t·ª´ 80
          verticalGap: 100,    // TƒÉng t·ª´ 70
          stagePadding: 250,   // TƒÉng t·ª´ 220
          startX: 120,
          startY: 280,
          sectionPadding: 25   // TƒÉng t·ª´ 12
        },
        default: {
          horizontalGap: 80,   // TƒÉng t·ª´ 60
          verticalGap: 70,     // TƒÉng t·ª´ 50
          stagePadding: 150,   // TƒÉng t·ª´ 120
          startX: 50,
          startY: 200,
          sectionPadding: 20   // TƒÉng t·ª´ 10
        }
      };
      
      const config = spacingConfig[layoutType] || spacingConfig.default;

      // Define stage padding - space around the stage
      const stage = clonedMap.stage || { x: 400, y: 50, width: 200, height: 60 };
      const stageBottom = stage.y + stage.height;

      // Get max width and height of sections for better arrangement
      let maxSectionWidth = 0;
      let maxSectionHeight = 0;
      sections.forEach(section => {
        maxSectionWidth = Math.max(maxSectionWidth, section.width || 120);
        maxSectionHeight = Math.max(maxSectionHeight, section.height || 100);
      });

      // TƒÉng k√≠ch th∆∞·ªõc t·ªëi thi·ªÉu ƒë·ªÉ gi·∫£m ch·ªìng l·∫•n
      maxSectionWidth = Math.max(maxSectionWidth, 180);  // TƒÉng t·ª´ 150
      maxSectionHeight = Math.max(maxSectionHeight, 150); // TƒÉng t·ª´ 120

      // Determine column count based on screen space
      const totalWidth = CANVAS_WIDTH - config.startX * 2;
      const columnsCount = Math.floor(totalWidth / (maxSectionWidth + config.horizontalGap));
      const columns = Math.max(1, Math.min(columnsCount, 3)); // Gi·∫£m t·ª´ 4 xu·ªëng 3 c·ªôt

      // Special layout for stadium/arena types
      if (['footballStadium', 'basketballArena'].includes(layoutType)) {
        // Place sections in U shape around the stage/field
        const leftStart = stage.x - config.stagePadding;
        const rightStart = stage.x + stage.width + config.horizontalGap;
        const bottomStart = stageBottom + config.verticalGap;
        
        // Calculate how many sections on each side
        const totalSections = sections.length;
        const sectionsPerSide = Math.max(1, Math.ceil(totalSections / 3));
        
        // Ph√¢n b·ªï l·∫°i c√°c khu v·ª±c xung quanh s√¢n
        sections.forEach((section, index) => {
          // ƒê·∫∑t ƒë·ªô r·ªông v√† cao t·ªëi thi·ªÉu ƒë·ªÉ tr√°nh sections qu√° nh·ªè
          section.width = Math.max(section.width || 180, 180);
          section.height = Math.max(section.height || 150, 150);
          
          // T√≠nh to√°n v·ªã tr√≠ d·ª±a tr√™n index
          const groupIndex = Math.floor(index / sectionsPerSide);
          const indexInGroup = index % sectionsPerSide;
          
          if (groupIndex === 0) {
            // Left side sections - ƒê·∫∑t c√°c khu v·ª±c b√™n tr√°i c√°ch xa h∆°n
            section.x = leftStart - section.width - config.sectionPadding * (indexInGroup + 1) * 1.5;
            section.y = stageBottom + indexInGroup * (section.height + config.verticalGap);
          } else if (groupIndex === 1) {
            // Bottom sections - ƒê·∫∑t c√°c khu v·ª±c d∆∞·ªõi c√πng c√°ch xa h∆°n
            const totalWidth = sectionsPerSide * section.width + (sectionsPerSide - 1) * config.horizontalGap * 1.5;
            const startX = stage.x + (stage.width - totalWidth) / 2;
            
            section.x = startX + indexInGroup * (section.width + config.horizontalGap * 1.5);
            section.y = bottomStart + config.stagePadding;
          } else {
            // Right side sections - ƒê·∫∑t c√°c khu v·ª±c b√™n ph·∫£i c√°ch xa h∆°n
            section.x = rightStart + config.sectionPadding * (indexInGroup + 1) * 1.5;
            section.y = stageBottom + indexInGroup * (section.height + config.verticalGap);
          }
          
          // ƒê·∫£m b·∫£o nh√£n khu v·ª±c ƒë∆∞·ª£c ƒë·∫∑t ·ªü v·ªã tr√≠ ph√π h·ª£p
          section.labelX = section.x + section.width / 2;
          section.labelY = section.y - 20;
        });
      } else {
        // Non-sports venues - standard grid layout with improved spacing
        const rows = Math.ceil(sections.length / columns);
        const horizontalSpacing = config.horizontalGap + maxSectionWidth;
        const verticalSpacing = config.verticalGap + maxSectionHeight;
        
        sections.forEach((section, index) => {
          // ƒê·∫∑t ƒë·ªô r·ªông v√† cao t·ªëi thi·ªÉu ƒë·ªÉ tr√°nh sections qu√° nh·ªè
          section.width = Math.max(section.width || 180, 180);
          section.height = Math.max(section.height || 150, 150);
          
          // Calculate position based on grid pattern
          const row = Math.floor(index / columns);
          const col = index % columns;
          
          // Position below stage with padding
          const topStart = stageBottom + config.stagePadding;
          
          section.x = config.startX + col * (horizontalSpacing + 20); // Th√™m 20px spacing
          section.y = topStart + row * (verticalSpacing + 20); // Th√™m 20px spacing
          
          // ƒê·∫£m b·∫£o nh√£n khu v·ª±c ƒë∆∞·ª£c ƒë·∫∑t ·ªü v·ªã tr√≠ ph√π h·ª£p
          section.labelX = section.x + section.width / 2;
          section.labelY = section.y - 20;
        });
      }
      
      // Check for any overlaps and fix them
      let hasOverlap = true;
      const maxIterations = 15; // TƒÉng t·ª´ 10 l√™n 15
      let iteration = 0;
      
      while (hasOverlap && iteration < maxIterations) {
        hasOverlap = false;
        iteration++;
        
        // Check all pairs of sections for overlaps
        for (let i = 0; i < sections.length; i++) {
          for (let j = i + 1; j < sections.length; j++) {
            const section1 = sections[i];
            const section2 = sections[j];
            
            if (isOverlapping(section1, section2)) {
              hasOverlap = true;
              // Move section2 to avoid overlap - s·ª≠ d·ª•ng chi·∫øn l∆∞·ª£c ph√¢n t√°n
              if (section1.x <= section2.x) {
                // section2 n·∫±m b√™n ph·∫£i section1
                section2.x = section1.x + section1.width + config.sectionPadding * 2;
              } else {
                // section2 n·∫±m b√™n tr√°i section1
                section2.x = section1.x - section2.width - config.sectionPadding * 2;
              }
              
              // N·∫øu v·∫´n ch·ªìng l√™n theo chi·ªÅu d·ªçc
              if (isOverlapping(section1, section2)) {
                if (section1.y <= section2.y) {
                  // section2 n·∫±m b√™n d∆∞·ªõi section1
                  section2.y = section1.y + section1.height + config.sectionPadding * 2;
                } else {
                  // section2 n·∫±m b√™n tr√™n section1
                  section2.y = section1.y - section2.height - config.sectionPadding * 2;
                }
              }
              
              // C·∫≠p nh·∫≠t l·∫°i v·ªã tr√≠ nh√£n
              section2.labelX = section2.x + section2.width / 2;
              section2.labelY = section2.y - 20;
            }
          }
        }
      }
      
      return sections;
    };
    
    clonedMap.sections = arrangeInGrid(clonedMap.sections);
    return clonedMap;
  };

  // Switch between design modes
  const handleDesignModeChange = (mode) => {
    // Lu√¥n ƒë·∫∑t mode l√† 'custom' b·∫•t k·ªÉ input
    setDesignMode('custom');
    
    // Reset manual editing flag
    setIsEditingTicketTypesManually(false);
  };

  useEffect(() => {
    if (seatOptions.venueType && (!customSeatingMap || customSeatingMap.layoutType !== seatOptions.venueType)) {
      // Update stage and layout type when venue type changes
      const newStage = getInitialStage(seatOptions.venueType);
      setCustomSeatingMap(prevMap => ({
        ...prevMap,
        stage: newStage,
        layoutType: seatOptions.venueType
      }));
    }
  }, [seatOptions.venueType]);

  // Helper function to prevent form submission when pressing Enter
  const preventEnterSubmit = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
    }
  };

  // Th√™m UI cho ph·∫ßn qu·∫£n l√Ω v·∫≠t th·ªÉ ph·ª• tr·ª£ trong Step 3
  const renderVenueObjectsManager = () => {
    return (
      <div className="bg-gray-50 p-4 rounded-lg shadow-inner mb-6">
        <h3 className="text-lg font-semibold mb-3">Th√™m v·∫≠t th·ªÉ ph·ª• tr·ª£</h3>
        <div className="flex flex-wrap gap-2 mb-4">
          {VENUE_OBJECT_TYPES.map(type => (
            <button
              key={type.value}
              className="px-3 py-2 bg-white border rounded-md hover:bg-gray-50 text-sm"
              style={{ borderColor: type.color, color: type.color }}
              onClick={(e) => handleVenueObjectButtonClick(e, type.value)}
              type="button" // ƒê·∫£m b·∫£o n√∫t kh√¥ng submit form
            >
              {type.label}
            </button>
          ))}
        </div>
        
        {(customSeatingMap.venueObjects?.length > 0) ? (
          <div>
            <h4 className="text-md font-medium mb-2">V·∫≠t th·ªÉ ƒë√£ th√™m ({customSeatingMap.venueObjects.length})</h4>
            <div className="bg-white rounded-md border border-gray-200 overflow-hidden">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Lo·∫°i</th>
                    <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Nh√£n</th>
                    <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">V·ªã tr√≠</th>
                    <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Thao t√°c</th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {customSeatingMap.venueObjects.map((obj, index) => (
                    <tr key={index}>
                      <td className="px-3 py-2 whitespace-nowrap">
                        <span className="inline-block w-3 h-3 rounded-full mr-2" style={{ backgroundColor: obj.color }}></span>
                        {VENUE_OBJECT_TYPES.find(t => t.value === obj.objectType)?.label || obj.objectType}
                      </td>
                      <td className="px-3 py-2 whitespace-nowrap">
                        <input
                          type="text"
                          className="border rounded px-2 py-1 text-sm w-full"
                          value={obj.label || ''}
                          onChange={(e) => updateVenueObject(index, 'label', e.target.value)}
                        />
                      </td>
                      <td className="px-3 py-2 whitespace-nowrap text-sm">
                        X: {obj.x?.toFixed(0) || 0}, Y: {obj.y?.toFixed(0) || 0}
                      </td>
                      <td className="px-3 py-2 whitespace-nowrap text-sm">
                        <button
                          onClick={(e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            removeVenueObject(index);
                          }}
                          className="text-red-600 hover:text-red-900"
                          type="button"
                        >
                          X√≥a
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
            <p className="text-sm text-gray-500 mt-2">
              B·∫°n c√≥ th·ªÉ k√©o th·∫£ c√°c v·∫≠t th·ªÉ tr√™n b·∫£n thi·∫øt k·∫ø ƒë·ªÉ ƒëi·ªÅu ch·ªânh v·ªã tr√≠.
            </p>
          </div>
        ) : (
          <p className="text-sm text-gray-500">Ch∆∞a c√≥ v·∫≠t th·ªÉ ph·ª• tr·ª£ n√†o ƒë∆∞·ª£c th√™m.</p>
        )}
      </div>
    );
  };

  // Return component
  return (
    <div style={styles.container}>
      <div style={styles.header}>
        <h2>üé™ T·∫°o S·ª± Ki·ªán C√≥ Ch·ªó Ng·ªìi</h2>
        <p>T·∫°o s·ª± ki·ªán v·ªõi h·ªá th·ªëng qu·∫£n l√Ω ch·ªó ng·ªìi th√¥ng minh</p>
      </div>
      
      {/* Form Steps */}
      <div style={{ display: 'flex', justifyContent: 'center', marginBottom: '20px' }}>
        {steps.map((step) => (
          <div
            key={step.id}
            style={{
              margin: '0 10px',
              padding: '10px 20px',
              borderRadius: '20px',
              backgroundColor: currentStep === step.id ? '#3b82f6' : '#e5e7eb',
              color: currentStep === step.id ? 'white' : 'black',
              fontWeight: currentStep === step.id ? 'bold' : 'normal'
            }}
          >
            <span style={{ marginRight: '5px' }}>{step.id}.</span>
            <span>{step.name}</span>
          </div>
        ))}
      </div>
      
      {message && <div style={{ padding: '10px', backgroundColor: message.includes('th√†nh c√¥ng') ? '#d1fae5' : '#fee2e2', borderRadius: '4px', marginBottom: '20px' }}>{message}</div>}
      
      <form onSubmit={handleSubmit} style={{ width: '100%' }}>
        {/* Step 1: Basic Information */}
        {currentStep === 1 && (
          <div style={styles.formSection}>
            <h3>üìù Th√¥ng Tin S·ª± Ki·ªán</h3>
            
            {/* Upload Images Section */}
            <div style={styles.formSection}>
              <h4>üñºÔ∏è H√¨nh ·∫¢nh S·ª± Ki·ªán</h4>
              <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px' }}>
                <ImageUpload
                  image={eventData.images.logo}
                  handleImageUpload={handleImageUpload}
                  type="logo"
                  title="Th√™m logo s·ª± ki·ªán"
                  description="(T·ª∑ l·ªá 720x950, t·ªëi ƒëa 5MB)"
                />
                <ImageUpload
                  image={eventData.images.banner}
                  handleImageUpload={handleImageUpload}
                  type="banner"
                  title="Th√™m ·∫£nh n·ªÅn s·ª± ki·ªán"
                  description="(T·ª∑ l·ªá 1200x720, t·ªëi ƒëa 10MB)"
                />
              </div>
            </div>
            
            <div style={styles.formGroup}>
              <label style={styles.label} htmlFor="title">T√™n s·ª± ki·ªán *</label>
              <input
                style={styles.input}
                type="text"
                id="title"
                name="title"
                value={eventData.title}
                onChange={handleEventDataChange}
                placeholder="V√≠ d·ª•: Concert nh·∫°c pop 2024"
                required
                onKeyDown={preventEnterSubmit}
              />
            </div>
            
            <div style={styles.formGroup}>
              <label style={styles.label} htmlFor="description">M√¥ t·∫£ ng·∫Øn *</label>
              <textarea
                style={{...styles.input, minHeight: '100px'}}
                id="description"
                name="description"
                value={eventData.description}
                onChange={handleEventDataChange}
                placeholder="M√¥ t·∫£ ng·∫Øn g·ªçn v·ªÅ s·ª± ki·ªán"
                rows="3"
                required
                onKeyDown={preventEnterSubmit}
              />
            </div>
            
            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px' }}>
              <div style={styles.formGroup}>
                <label style={styles.label} htmlFor="startDate">Ng√†y b·∫Øt ƒë·∫ßu *</label>
                <input
                  style={styles.input}
                  type="datetime-local"
                  id="startDate"
                  name="startDate"
                  value={eventData.startDate}
                  onChange={handleEventDataChange}
                  required
                  onKeyDown={preventEnterSubmit}
                />
              </div>
              
              <div style={styles.formGroup}>
                <label style={styles.label} htmlFor="endDate">Ng√†y k·∫øt th√∫c *</label>
                <input
                  style={styles.input}
                  type="datetime-local"
                  id="endDate"
                  name="endDate"
                  value={eventData.endDate}
                  onChange={handleEventDataChange}
                  required
                  onKeyDown={preventEnterSubmit}
                />
              </div>
            </div>
            
            {/* Location */}
            <div style={styles.formGroup}>
              <label style={styles.label} htmlFor="venueName">T√™n ƒë·ªãa ƒëi·ªÉm</label>
              <input
                style={styles.input}
                type="text"
                id="venueName"
                name="location.venueName"
                value={eventData.location.venueName}
                onChange={handleEventDataChange}
                placeholder="V√≠ d·ª•: S√¢n v·∫≠n ƒë·ªông M·ªπ ƒê√¨nh"
                onKeyDown={preventEnterSubmit}
              />
            </div>
            
            <div style={styles.formGroup}>
              <label style={styles.label} htmlFor="address">ƒê·ªãa ch·ªâ</label>
              <input
                style={styles.input}
                type="text"
                id="address"
                name="location.address"
                value={eventData.location.address}
                onChange={handleEventDataChange}
                placeholder="ƒê·ªãa ch·ªâ c·ª• th·ªÉ"
                onKeyDown={preventEnterSubmit}
              />
            </div>
            
            <div style={styles.stepActions}>
              <div></div> {/* Empty div for spacing */}
              <button type="button" style={styles.button} onClick={nextStep}>Ti·∫øp theo ‚Üí</button>
            </div>
          </div>
        )}

        {/* Step 2: Seat & Ticket Configuration (ƒë·ªïi t·ª´ step 3) */}
        {currentStep === 2 && (
          <div className="form-section">
            {/* B·ªè Design Mode Selection */}
            
            {/* Custom Mode */}
            <div className="custom-mode-section">
              <h3>üé® Thi·∫øt k·∫ø s∆° ƒë·ªì t√πy ch·ªânh</h3>
              <p>K√©o th·∫£ c√°c khu v·ª±c, s√¢n kh·∫•u ƒë·ªÉ t·∫°o layout ph√π h·ª£p v·ªõi s·ª± ki·ªán c·ªßa b·∫°n</p>
              
              {/* Info about auto-arrange */}
              <div className="info-box">
          {/* Step 2: Seat & Ticket Configuration (ƒë·ªïi t·ª´ step 3) */}
          {currentStep === 2 && (
            <div className="form-section">
              {/* B·ªè Design Mode Selection */}
              
              {/* Custom Mode */}
              <div className="custom-mode-section">
                <h3>üé® Thi·∫øt k·∫ø s∆° ƒë·ªì t√πy ch·ªânh</h3>
                <p>K√©o th·∫£ c√°c khu v·ª±c, s√¢n kh·∫•u ƒë·ªÉ t·∫°o layout ph√π h·ª£p v·ªõi s·ª± ki·ªán c·ªßa b·∫°n</p>
                
                {/* Info about auto-arrange */}
                <div className="info-box">
                  <p>‚ÑπÔ∏è <strong>L∆∞u √Ω:</strong> Khi t·∫°o s·ª± ki·ªán, h·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông cƒÉn ch·ªânh c√°c sections ƒë·ªÉ tr√°nh ch·ªìng l·∫•p, nh∆∞ng v·∫´n gi·ªØ nguy√™n layout t·ªïng th·ªÉ m√† b·∫°n ƒë√£ thi·∫øt k·∫ø.</p>
                </div>
                
                {/* Auto-arrange button */}
                <div className="auto-arrange-section">
                  <button
                    type="button"
                    className="btn-secondary"
                    onClick={() => {
                      console.log('üîß Manual auto-arrange triggered');
                      const arrangedMap = autoArrangeSections(customSeatingMap);
                      setCustomSeatingMap(arrangedMap);
                      console.log('‚úÖ Sections auto-arranged manually');
                      
                      // Hi·ªÉn th·ªã toast th√¥ng b√°o
                      toast.info('ƒê√£ cƒÉn ch·ªânh t·ª± ƒë·ªông c√°c khu v·ª±c ƒë·ªÉ tr√°nh ch·ªìng l·∫•p', {
                        position: "top-right",
                        autoClose: 3000,
                        hideProgressBar: false,
                        closeOnClick: true,
                        pauseOnHover: true,
                        draggable: true,
                        progress: undefined,
                      });
                    }}
                  >
                    üîß Xem tr∆∞·ªõc cƒÉn ch·ªânh t·ª± ƒë·ªông
                  </button>
                  <small>Ki·ªÉm tra c√°ch h·ªá th·ªëng s·∫Ω cƒÉn ch·ªânh c√°c sections ƒë·ªÉ tr√°nh ch·ªìng l·∫•p</small>
                </div>
                
                <div className="seating-designer-container">
                  <InteractiveSeatingDesigner 
                    initialSeatingMap={customSeatingMap}
                    onSeatingMapChange={handleCustomSeatingMapChange}
                    ticketTypes={ticketTypes}
                    onTicketTypesChange={setTicketTypes}
                  />
                </div>

                {/* Add Venue Objects Manager here */}
                {renderVenueObjectsManager()}
              </div>

              {/* Ticket Types */}
              <div className="form-section">
                <h3>üé´ Lo·∫°i V√©</h3>
                <p>Thi·∫øt l·∫≠p c√°c lo·∫°i v√© cho s·ª± ki·ªán c·ªßa b·∫°n.</p>
                
                {/* Manual editing indicator */}
                {isEditingTicketTypesManually && (
                  <div className="manual-editing-indicator">
                    <p>üìù B·∫°n ƒëang ch·ªânh s·ª≠a th·ªß c√¥ng. Ticket types s·∫Ω kh√¥ng t·ª± ƒë·ªông sync v·ªõi seating map.</p>
                    <button
                      type="button"
                      className="btn-secondary"
                      onClick={() => setIsEditingTicketTypesManually(false)}
                    >
                      üîÑ B·∫≠t l·∫°i Auto-sync v·ªõi seating map
                    </button>
                  </div>
                )}
                
                {ticketTypes.map((ticketType, index) => (
                  <div key={index} className="ticket-type-item">
                    <div className="ticket-type-header">
                      <h4>üé´ {ticketType.name || `Lo·∫°i v√© ${index + 1}`}</h4>
                      {ticketTypes.length > 1 && (
                        <button
                          type="button"
                          className="remove-ticket-type"
                          onClick={(e) => removeTicketType(index, e)}
                        >
                          X√≥a
                        </button>
                      )}
                    </div>

                    <div className="form-row">
                      <div className="form-group">
                        <label>T√™n lo·∫°i v√© *</label>
                        <input
                          type="text"
                          value={ticketType.name}
                          onChange={(e) => handleTicketTypeChange(index, 'name', e.target.value)}
                          placeholder="VIP, Th∆∞·ªùng, ..."
                          required
                          onKeyDown={preventEnterSubmit}
                        />
                      </div>

                      <div className="form-group">
                        <label>Gi√° (VND) *</label>
                        <input
                          type="number"
                          value={ticketType.price}
                          onChange={(e) => handleTicketTypeChange(index, 'price', e.target.value)}
                          min="0"
                          placeholder="500000"
                          required
                          onKeyDown={preventEnterSubmit}
                        />
                      </div>

                      <div className="form-group">
                        <label>S·ªë l∆∞·ª£ng *</label>
                        <input
                          type="number"
                          value={ticketType.quantity}
                          onChange={(e) => handleTicketTypeChange(index, 'quantity', e.target.value)}
                          min="0"
                          required
                          onKeyDown={preventEnterSubmit}
                        />
                      </div>

                      <div className="form-group">
                        <label>M√†u s·∫Øc</label>
                        <div className="color-picker-container">
                          <input
                            type="color"
                            value={ticketType.color || '#6B7280'}
                            onChange={(e) => handleTicketTypeChange(index, 'color', e.target.value)}
                            className="color-picker"
                            onKeyDown={preventEnterSubmit}
                          />
                          <span className="color-preview" style={{ backgroundColor: ticketType.color || '#6B7280' }}></span>
                        </div>
                      </div>
                    </div>

                    <div className="form-group">
                      <label>M√¥ t·∫£</label>
                      <textarea
                        value={ticketType.description}
                        onChange={(e) => handleTicketTypeChange(index, 'description', e.target.value)}
                        placeholder="M√¥ t·∫£ v·ªÅ lo·∫°i v√© n√†y"
                        rows="2"
                        onKeyDown={preventEnterSubmit}
                      />
                    </div>
                  </div>
                ))}

                <button
                  type="button"
                  className="add-ticket-type"
                  onClick={(e) => {
                    e.preventDefault();
                    addTicketType(e);
                  }}
                >
                  + Th√™m lo·∫°i v√©
                </button>

                <div className="step-actions">
                  <button type="button" onClick={prevStep}>‚Üê Quay l·∫°i</button>
                  <button type="button" onClick={nextStep}>Ti·∫øp theo ‚Üí</button>
                </div>
              </div>
            </div>
          )}

          {/* Step 3: Confirmation (ƒë·ªïi t·ª´ step 4) */}
          {currentStep === 3 && (
            <div className="form-section">
              <h3>‚úÖ X√°c Nh·∫≠n Th√¥ng Tin</h3>
              <p>Vui l√≤ng ki·ªÉm tra l·∫°i th√¥ng tin tr∆∞·ªõc khi t·∫°o s·ª± ki·ªán</p>
              
              <div className="confirmation-details">
                <div className="confirmation-section">
                  <h4>üìù Th√¥ng Tin S·ª± Ki·ªán</h4>
                  <div className="confirmation-item">
                    <span>T√™n s·ª± ki·ªán:</span>
                    <strong>{eventData.title}</strong>
                  </div>
                  <div className="confirmation-item">
                    <span>Th·ªùi gian:</span>
                    <strong>
                      {new Date(eventData.startDate).toLocaleString('vi-VN')} - {new Date(eventData.endDate).toLocaleString('vi-VN')}
                    </strong>
                  </div>
                  <div className="confirmation-item">
                    <span>ƒê·ªãa ƒëi·ªÉm:</span>
                    <strong>{eventData.location.venueName}, {eventData.location.address}</strong>
                  </div>
                </div>
                
                <div className="confirmation-section">
                  <h4>üé´ Th√¥ng Tin V√©</h4>
                  <div className="ticket-types-summary">
                    {ticketTypes.map((tt, index) => (
                      <div key={index} className="ticket-type-summary">
                        <div className="ticket-color" style={{ backgroundColor: tt.color }}></div>
                        <div className="ticket-details">
                          <strong>{tt.name}</strong>
                          <span>{tt.quantity} v√© √ó {tt.price.toLocaleString('vi-VN')}ƒë</span>
                        </div>
                      </div>
                    ))}
                  </div>
                  <div className="confirmation-item total">
                    <span>T·ªïng s·ªë v√©:</span>
                    <strong>{ticketTypes.reduce((sum, tt) => sum + tt.quantity, 0)} v√©</strong>
                  </div>
                </div>
                
                <div className="confirmation-section">
                  <h4>üó∫Ô∏è S∆° ƒê·ªì Ch·ªó Ng·ªìi</h4>
                  <div className="seating-map-summary">
                    <p>S∆° ƒë·ªì t√πy ch·ªânh v·ªõi {customSeatingMap.sections.length} khu v·ª±c</p>
                    <div className="seating-preview-container">
                      <SeatingPreview 
                        seatingMap={customSeatingMap} 
                        showLabels={true}
                        interactive={false}
                      />
                    </div>

                    {/* Display venue objects in confirmation */}
                    {customSeatingMap.venueObjects && customSeatingMap.venueObjects.length > 0 && (
                      <div className="venue-objects-summary mt-4">
                        <h5 className="text-md font-semibold">V·∫≠t th·ªÉ ph·ª• tr·ª£ ({customSeatingMap.venueObjects.length}):</h5>
                        <div className="flex flex-wrap gap-2 mt-2">
                          {customSeatingMap.venueObjects.map((obj, idx) => (
                            <div 
                              key={idx}
                              className="px-2 py-1 rounded-md text-sm flex items-center"
                              style={{ backgroundColor: `${obj.color}20`, color: obj.color, border: `1px solid ${obj.color}` }}
                            >
                              <span className="font-medium">{obj.label || VENUE_OBJECT_TYPES.find(t => t.value === obj.objectType)?.label || obj.objectType}</span>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              </div>
              
              <div className="step-actions">
                <button type="button" onClick={prevStep}>‚Üê Quay l·∫°i</button>
                <button 
                  type="submit" 
                  className="submit-button"
                  disabled={loading}
                >
                  {loading ? 'üîÑ ƒêang x·ª≠ l√Ω...' : '‚úÖ T·∫°o S·ª± Ki·ªán'}
                </button>
              </div>
            </div>
          )}
        </form>
      </div>
    </div>
  );
};

export default CreateEventWithSeating; 