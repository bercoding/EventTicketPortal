import React, { useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import axios from 'axios';
import { toast } from 'react-toastify';
import ImageUpload from '../../components/event/ImageUpload';
import SeatingPreview from '../../components/seating/SeatingPreview';
import InteractiveSeatingDesigner from '../../components/seating/InteractiveSeatingDesigner';
import './CreateEvent.css';

// Venue templates v·ªõi layout th√¥ng minh
const VENUE_TEMPLATES = {
  stadium: {
    name: 'S√¢n v·∫≠n ƒë·ªông',
    description: '3 khu VIP ph√≠a tr∆∞·ªõc, c√°c khu kh√°c xung quanh',
    defaultSections: 8,
    defaultSeats: 300,
    layoutType: 'stadium',
    ticketTypeTemplates: [
      { name: 'VIP Tier 1', price: 800000, description: 'H√†ng gh·∫ø ƒë·∫ßu, view t·ªët nh·∫•t', percentage: 15, color: '#8B5CF6' },
      { name: 'VIP Tier 2', price: 600000, description: 'Khu VIP ph√≠a sau', percentage: 20, color: '#3B82F6' },
      { name: 'Th∆∞·ªùng A', price: 400000, description: 'Khu kh√°n ƒë√†i ch√≠nh', percentage: 35, color: '#10B981' },
      { name: 'Th∆∞·ªùng B', price: 250000, description: 'Khu kh√°n ƒë√†i ph·ª•', percentage: 30, color: '#F97316' }
    ]
  },
  theater: {
    name: 'Nh√† h√°t / H·ªôi tr∆∞·ªùng',
    description: 'Layout truy·ªÅn th·ªëng v·ªõi gh·∫ø s·∫Øp x·∫øp theo h√†ng',
    defaultSections: 6,
    defaultSeats: 200,
    layoutType: 'theater',
    ticketTypeTemplates: [
      { name: 'VIP', price: 500000, description: 'Gh·∫ø h·∫°ng sang ph√≠a tr∆∞·ªõc', percentage: 30, color: '#8B5CF6' },
      { name: 'Th∆∞·ªùng', price: 300000, description: 'Gh·∫ø th√¥ng th∆∞·ªùng', percentage: 70, color: '#3B82F6' }
    ]
  },
  concert: {
    name: 'Concert Hall',
    description: 'S√¢n kh·∫•u trung t√¢m v·ªõi khu VIP g·∫ßn s√¢n kh·∫•u',
    defaultSections: 10,
    defaultSeats: 500,
    layoutType: 'concert',
    ticketTypeTemplates: [
      { name: 'Golden Circle', price: 1500000, description: 'G·∫ßn s√¢n kh·∫•u nh·∫•t', percentage: 10, color: '#F59E0B' },
      { name: 'VIP', price: 800000, description: 'Khu VIP v·ªõi d·ªãch v·ª• ƒë·∫∑c bi·ªát', percentage: 20, color: '#8B5CF6' },
      { name: 'Th∆∞·ªùng A', price: 500000, description: 'Khu kh√°n ƒë√†i ch√≠nh', percentage: 40, color: '#3B82F6' },
      { name: 'Th∆∞·ªùng B', price: 300000, description: 'Khu kh√°n ƒë√†i xa', percentage: 30, color: '#10B981' }
    ]
  },
  outdoor: {
    name: 'S·ª± ki·ªán ngo√†i tr·ªùi',
    description: 'Kh√¥ng gian m·ªü v·ªõi c√°c khu v·ª±c linh ho·∫°t',
    defaultSections: 5,
    defaultSeats: 150,
    layoutType: 'outdoor',
    ticketTypeTemplates: [
      { name: 'VIP Front', price: 600000, description: 'Khu v·ª±c ph√≠a tr∆∞·ªõc', percentage: 25, color: '#8B5CF6' },
      { name: 'General', price: 350000, description: 'Khu v·ª±c chung', percentage: 75, color: '#3B82F6' }
    ]
  },
  footballStadium: {
    name: 'S√¢n v·∫≠n ƒë·ªông b√≥ng ƒë√°',
    description: 'Layout s√¢n b√≥ng chuy√™n nghi·ªáp v·ªõi VIP t·∫ßng tr√™n, kh√°n ƒë√†i ch√≠nh v√† khu g√≥c',
    defaultSections: 12,
    defaultSeats: 1000,
    layoutType: 'footballStadium',
    ticketTypeTemplates: [
      { name: 'VIP Box', price: 2500000, description: 'H·ªôp VIP t·∫ßng tr√™n (DB1, DB2, DC1, DC2)', percentage: 20, color: '#DC2626' },
      { name: 'Premium', price: 1500000, description: 'Kh√°n ƒë√†i cao c·∫•p g·∫ßn s√¢n (DA1, DA2)', percentage: 20, color: '#7C3AED' },
      { name: 'Kh√°n ƒë√†i Ch√≠nh', price: 1000000, description: 'Kh√°n ƒë√†i ch√≠nh hai b√™n (DA3, DA4)', percentage: 30, color: '#2563EB' },
      { name: 'Kh√°n ƒë√†i G√≥c', price: 700000, description: 'Khu v·ª±c g√≥c s√¢n (KD_A, KD_B, KD_C)', percentage: 20, color: '#059669' },
      { name: 'FOH', price: 400000, description: 'Khu v·ª±c FOH v√† c√°c khu xa', percentage: 10, color: '#D97706' }
    ]
  },
  basketballArena: {
    name: 'S√¢n b√≥ng r·ªï',
    description: 'Arena b√≥ng r·ªï v·ªõi kh√°n ƒë√†i bao quanh s√¢n',
    defaultSections: 8,
    defaultSeats: 600,
    layoutType: 'basketballArena',
    ticketTypeTemplates: [
      { name: 'Courtside', price: 1500000, description: 'Gh·∫ø s√°t s√¢n v·ªõi tr·∫£i nghi·ªám t·ªët nh·∫•t', percentage: 10, color: '#DC2626' },
      { name: 'Lower Bowl', price: 800000, description: 'T·∫ßng d∆∞·ªõi g·∫ßn s√¢n', percentage: 30, color: '#7C3AED' },
      { name: 'Club Level', price: 600000, description: 'T·∫ßng club v·ªõi ti·ªán √≠ch', percentage: 25, color: '#2563EB' },
      { name: 'Upper Bowl', price: 350000, description: 'T·∫ßng tr√™n v·ªõi gi√° h·ª£p l√Ω', percentage: 35, color: '#059669' }
    ]
  }
};

const CreateEventWithSeating = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const templateInfo = location.state;
  
  const [loading, setLoading] = useState(false);
  const [message, setMessage] = useState('');
  const [currentStep, setCurrentStep] = useState(1);
  const [selectedVenueTemplate, setSelectedVenueTemplate] = useState(null);
  const [previewSeatingMap, setPreviewSeatingMap] = useState(null);
  const [designMode, setDesignMode] = useState('template'); // 'template' or 'custom'
  const [customSeatingMap, setCustomSeatingMap] = useState({
    layoutType: 'custom',
    sections: [],
    stage: { x: 400, y: 50, width: 200, height: 60 }
  });
  const [isEditingTicketTypesManually, setIsEditingTicketTypesManually] = useState(false);
  
  const [eventData, setEventData] = useState({
    title: '',
    description: '',
    startDate: '',
    endDate: '',
    location: {
      type: 'offline',
      venueName: '',
      address: '',
      city: 'TP.HCM'
    },
    category: [],
    tags: [],
    visibility: 'public',
    status: 'pending',
    detailedDescription: {
      mainProgram: '',
      guests: '',
      specialExperiences: ''
    },
    termsAndConditions: '',
    images: {
      logo: '',
      banner: ''
    },
    organizer: {
      logo: '',
      name: '',
      info: ''
    }
  });

  const [seatOptions, setSeatOptions] = useState({
    totalSeats: 200,
    totalSections: 6,
    venueType: 'theater'
  });

  const [ticketTypes, setTicketTypes] = useState([
    {
      name: 'VIP',
      price: 500000,
      description: 'V√© h·∫°ng VIP v·ªõi v·ªã tr√≠ t·ªët nh·∫•t',
      quantity: 60,
      color: '#8B5CF6'
    },
    {
      name: 'Th∆∞·ªùng',
      price: 300000,
      description: 'V√© th∆∞·ªùng v·ªõi gi√° h·ª£p l√Ω',
      quantity: 140,
      color: '#3B82F6'
    }
  ]);

  // Apply venue template
  const applyVenueTemplate = (templateKey) => {
    const template = VENUE_TEMPLATES[templateKey];
    setSelectedVenueTemplate(templateKey);
    
    // Reset manual editing flag when applying template
    setIsEditingTicketTypesManually(false);
    
    setSeatOptions({
      totalSeats: template.defaultSeats,
      totalSections: template.defaultSections,
      venueType: template.layoutType
    });

    // Calculate ticket quantities based on percentages and preserve colors
    const calculatedTicketTypes = template.ticketTypeTemplates.map(tt => ({
      ...tt,
      quantity: Math.floor(template.defaultSeats * tt.percentage / 100)
    }));

    setTicketTypes(calculatedTicketTypes);
    console.log('üé® Applied template with colored ticket types:', calculatedTicketTypes);
    
    // Generate preview v·ªõi template m·ªõi
    setTimeout(() => {
      generatePreviewMap(template.defaultSeats, template.defaultSections, template.layoutType);
    }, 100);
  };

  // Smart seat distribution when changing total seats - preserve colors
  const handleSeatChange = (newTotalSeats) => {
    if (selectedVenueTemplate) {
      const template = VENUE_TEMPLATES[selectedVenueTemplate];
      const updatedTicketTypes = ticketTypes.map(tt => {
        const templateTT = template.ticketTypeTemplates.find(t => t.name === tt.name);
        const percentage = templateTT ? templateTT.percentage : (tt.quantity / seatOptions.totalSeats * 100);
        return {
          ...tt,
          quantity: Math.floor(newTotalSeats * percentage / 100),
          color: tt.color || templateTT?.color || '#6B7280' // Preserve existing color
        };
      });
      setTicketTypes(updatedTicketTypes);
    }
    
    setSeatOptions(prev => ({ ...prev, totalSeats: parseInt(newTotalSeats) }));
    generatePreviewMap(newTotalSeats, seatOptions.totalSections, seatOptions.venueType);
  };

  // Generate preview seating map
  const generatePreviewMap = async (totalSeats = seatOptions.totalSeats, totalSections = seatOptions.totalSections, venueType = seatOptions.venueType) => {
    try {
      console.log('üîÑ Generating preview...', { totalSeats, totalSections, venueType });
      
      const response = await axios.post('http://localhost:5001/api/events/preview-seating', {
        seatOptions: { totalSeats, totalSections, venueType },
        ticketTypes: ticketTypes.map(tt => ({ ...tt, _id: `temp_${tt.name}` }))
      }, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });
      
      if (response.data.success) {
        console.log('‚úÖ Preview generated successfully');
        setPreviewSeatingMap(response.data.data);
      }
    } catch (error) {
      console.error('‚ùå Error generating preview:', error);
      
      // Better fallback with mock sections
      const mockSections = [];
      const seatsPerSection = Math.floor(totalSeats / totalSections);
      
      for (let i = 0; i < Math.min(totalSections, 3); i++) {
        mockSections.push({
          name: `Khu ${String.fromCharCode(65 + i)}`,
          capacity: seatsPerSection,
          x: 100 + i * 200,
          y: 200 + i * 50,
          width: 150,
          height: 100,
          rows: [{
            rowNumber: 1,
            rowLetter: 'A',
            seats: Array.from({ length: Math.min(seatsPerSection, 10) }, (_, j) => ({
              seatNumber: j + 1,
              x: 100 + i * 200 + j * 15,
              y: 200 + i * 50,
              status: 'available'
            }))
          }]
        });
      }
      
      setPreviewSeatingMap({
        layoutType: venueType,
        sections: mockSections,
        stage: { x: 250, y: 20, width: 300, height: 60 }
      });
    }
  };

  const handleEventDataChange = (e) => {
    const { name, value } = e.target;
    if (name.includes('.')) {
      const [parent, child] = name.split('.');
      setEventData(prev => ({
        ...prev,
        [parent]: {
          ...prev[parent],
          [child]: value
        }
      }));
    } else {
      setEventData(prev => ({ ...prev, [name]: value }));
    }
  };

  const handleImageUpload = async (e, imageType) => {
    const file = e.target.files[0];
    if (file) {
      try {
        // Show preview immediately
        const reader = new FileReader();
        reader.onloadend = () => {
          setEventData(prev => ({
            ...prev,
            images: {
              ...prev.images,
              [imageType]: reader.result
            }
          }));
        };
        reader.readAsDataURL(file);

        // Upload to server
        const formData = new FormData();
        formData.append(imageType, file);

        const token = localStorage.getItem('token');
        const response = await axios.post(
          'http://localhost:5001/api/events/upload-images',
          formData,
          {
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'multipart/form-data'
            }
          }
        );

        if (response.data.success) {
          // Update with server URL
          setEventData(prev => ({
            ...prev,
            images: {
              ...prev.images,
              [`${imageType}_url`]: `http://localhost:5001${response.data.data[imageType]}`
            }
          }));
          toast.success(`Upload ${imageType} th√†nh c√¥ng!`);
        }
      } catch (error) {
        console.error('Upload error:', error);
        toast.error(`L·ªói upload ${imageType}`);
      }
    }
  };

  const handleSeatOptionsChange = (e) => {
    const { name, value } = e.target;
    if (name === 'totalSeats') {
      handleSeatChange(value);
    } else {
      const newSeatOptions = { ...seatOptions, [name]: parseInt(value) };
      setSeatOptions(newSeatOptions);
      // Generate preview khi thay ƒë·ªïi venueType ho·∫∑c totalSections
      setTimeout(() => {
        generatePreviewMap(newSeatOptions.totalSeats, newSeatOptions.totalSections, newSeatOptions.venueType);
      }, 300);
    }
  };

  const handleTicketTypeChange = (index, field, value) => {
    // Mark as manually editing when user changes ticket types
    console.log(`üéõÔ∏è User manually changed ticket type [${index}].${field} = ${value}`);
    console.log(`üéõÔ∏è Before: isEditingTicketTypesManually = ${isEditingTicketTypesManually}`);
    setIsEditingTicketTypesManually(true);
    console.log(`üéõÔ∏è After: isEditingTicketTypesManually = true`);
    
    const updatedTicketTypes = [...ticketTypes];
    
    if (field === 'price' || field === 'quantity') {
      updatedTicketTypes[index][field] = parseInt(value) || 0;
    } else {
      updatedTicketTypes[index][field] = value;
    }
    
    setTicketTypes(updatedTicketTypes);
    console.log(`üéõÔ∏è Updated ticket types:`, updatedTicketTypes);
    
    // Log m√†u s·∫Øc change ƒë·ªÉ debug
    if (field === 'color') {
      console.log(`üé® Color changed for ${updatedTicketTypes[index].name}: ${value}`);
    }
  };

  const addTicketType = () => {
    // Mark as manually editing when user adds ticket type
    setIsEditingTicketTypesManually(true);
    
    // Generate m√†u ng·∫´u nhi√™n cho ticket type m·ªõi
    const colors = ['#8B5CF6', '#3B82F6', '#10B981', '#F97316', '#EF4444', '#F59E0B', '#06B6D4', '#84CC16'];
    const randomColor = colors[Math.floor(Math.random() * colors.length)];
    
    setTicketTypes([...ticketTypes, {
      name: '',
      price: 0,
      description: '',
      quantity: 0,
      color: randomColor
    }]);
  };

  const removeTicketType = (index) => {
    if (ticketTypes.length > 1) {
      // Mark as manually editing when user removes ticket type
      setIsEditingTicketTypesManually(true);
      setTicketTypes(ticketTypes.filter((_, i) => i !== index));
    }
  };

  const nextStep = () => {
    // Validation cho step 2 (th√¥ng tin c∆° b·∫£n)
    if (currentStep === 2) {
      if (!eventData.startDate || !eventData.endDate) {
        setMessage('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß Ng√†y b·∫Øt ƒë·∫ßu v√† Ng√†y k·∫øt th√∫c v·ªõi gi·ªù c·ª• th·ªÉ.');
        return;
      }
      
      const startDate = new Date(eventData.startDate);
      const endDate = new Date(eventData.endDate);
      const now = new Date();
      
      // Ki·ªÉm tra th·ªùi gian trong t∆∞∆°ng lai
      if (startDate <= now) {
        setMessage('Ng√†y b·∫Øt ƒë·∫ßu ph·∫£i trong t∆∞∆°ng lai (√≠t nh·∫•t 1 gi·ªù t·ª´ b√¢y gi·ªù).');
        return;
      }
      
      if (startDate >= endDate) {
        setMessage('Ng√†y k·∫øt th√∫c ph·∫£i sau ng√†y b·∫Øt ƒë·∫ßu.');
        return;
      }
      
      // Ki·ªÉm tra th·ªùi l∆∞·ª£ng t·ªëi thi·ªÉu (√≠t nh·∫•t 30 ph√∫t)
      const diffMs = endDate - startDate;
      if (diffMs < 30 * 60 * 1000) {
        setMessage('S·ª± ki·ªán ph·∫£i c√≥ th·ªùi l∆∞·ª£ng √≠t nh·∫•t 30 ph√∫t.');
        return;
      }
      
      // Clear message n·∫øu validation pass
      setMessage('');
    }
    
    if (currentStep < 4) setCurrentStep(currentStep + 1);
  };

  const prevStep = () => {
    if (currentStep > 1) setCurrentStep(currentStep - 1);
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setMessage('');

    try {
      // Debug: Log current state before validation
      console.log('üéõÔ∏è Form submit debug:');
      console.log('  - designMode:', designMode);
      console.log('  - seatOptions:', seatOptions);
      console.log('  - customSeatingMap sections:', customSeatingMap?.sections?.length || 0);
      console.log('  - ticketTypes:', ticketTypes.length);

      // Validate input
      if (!eventData.title || !eventData.description || !eventData.startDate || !eventData.endDate) {
        setMessage('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin c∆° b·∫£n c·ªßa s·ª± ki·ªán.');
        setLoading(false);
        return;
      }

      // Validate design mode specific requirements
      if (designMode === 'template') {
      if (seatOptions.totalSeats < 1 || seatOptions.totalSections < 1) {
        setMessage('S·ªë gh·∫ø v√† s·ªë khu ph·∫£i l·ªõn h∆°n 0.');
        setLoading(false);
        return;
        }
      } else if (designMode === 'custom') {
        if (!customSeatingMap || !customSeatingMap.sections || customSeatingMap.sections.length === 0) {
          setMessage('Vui l√≤ng thi·∫øt k·∫ø s∆° ƒë·ªì ch·ªó ng·ªìi ho·∫∑c chuy·ªÉn v·ªÅ template mode.');
          setLoading(false);
          return;
        }
      }

      if (ticketTypes.some(tt => !tt.name || tt.price <= 0 || tt.quantity <= 0)) {
        setMessage('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin lo·∫°i v√© v√† ƒë·∫£m b·∫£o gi√°, s·ªë l∆∞·ª£ng > 0.');
        setLoading(false);
        return;
      }

      // Calculate total capacity based on design mode
      let totalCapacity;
      let finalCustomSeatingMap = customSeatingMap;
      
      if (designMode === 'custom') {
        // Auto-arrange sections to prevent overlapping
        console.log('üîß Auto-arranging sections to prevent overlaps...');
        finalCustomSeatingMap = autoArrangeSections(customSeatingMap);
        
        // Log changes if any
        const hasChanges = finalCustomSeatingMap.sections.some((section, index) => {
          const original = customSeatingMap.sections[index];
          return original && (section.x !== original.x || section.y !== original.y);
        });
        
        if (hasChanges) {
          console.log('‚úÖ Sections auto-arranged to prevent overlaps');
          // Update state to show arranged positions (optional)
          setCustomSeatingMap(finalCustomSeatingMap);
          
          // Show success message
          setMessage('üîß C√°c sections ƒë√£ ƒë∆∞·ª£c t·ª± ƒë·ªông cƒÉn ch·ªânh ƒë·ªÉ tr√°nh ch·ªìng l·∫•p. V·ªã tr√≠ t·ªïng th·ªÉ v·∫´n ƒë∆∞·ª£c gi·ªØ nguy√™n.');
          setTimeout(() => setMessage(''), 3000);
        } else {
          console.log('‚úÖ No overlapping sections detected');
        }
        
        totalCapacity = finalCustomSeatingMap.sections.reduce((total, section) => total + (section.capacity || 0), 0);
      } else {
        totalCapacity = seatOptions.totalSeats;
      }

      const totalTicketQuantity = ticketTypes.reduce((sum, tt) => sum + tt.quantity, 0);
      if (totalTicketQuantity !== totalCapacity) {
        setMessage(`T·ªïng s·ªë l∆∞·ª£ng v√© (${totalTicketQuantity}) ph·∫£i b·∫±ng t·ªïng capacity (${totalCapacity}).`);
        setLoading(false);
        return;
      }

      const token = localStorage.getItem('token');
      
      // Prepare images data v·ªõi server URLs
      const imagesToSend = {
        logo: eventData.images.logo_url || eventData.images.logo || '',
        banner: eventData.images.banner_url || eventData.images.banner || ''
      };
      
      // Prepare organizer data v·ªõi server URL  
      const organizerToSend = {
        ...eventData.organizer,
        logo: eventData.organizer.logo_url || eventData.organizer.logo || ''
      };
      
      console.log('üì∏ Images to send:', imagesToSend);
      console.log('üë• Organizer to send:', organizerToSend);
      
      // Debug: Log request payload
      const requestPayload = {
          ...eventData,
          images: imagesToSend,
          organizer: organizerToSend,
        seatOptions: designMode === 'template' ? seatOptions : undefined,
        customSeatingMap: designMode === 'custom' ? finalCustomSeatingMap : undefined,
        designMode,
          ticketTypes,
        templateType: 'seating'
      };
      console.log('üì§ Request payload:', JSON.stringify(requestPayload, null, 2));
      
      const response = await axios.post(
        'http://localhost:5001/api/events/create-with-seating',
        requestPayload,
        {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        }
      );

      if (response.data.success) {
        setMessage('T·∫°o s·ª± ki·ªán th√†nh c√¥ng!');
        setTimeout(() => {
          navigate(`/events/${response.data.data._id}`);
        }, 2000);
      }
    } catch (error) {
      console.error('Error creating event:', error);
      setMessage(error.response?.data?.message || 'C√≥ l·ªói x·∫£y ra khi t·∫°o s·ª± ki·ªán.');
    } finally {
      setLoading(false);
    }
  };

  // Handle custom seating map changes
  const handleCustomSeatingMapChange = (newSeatingMap) => {
    console.log(`üó∫Ô∏è Seating map changed, manual editing flag: ${isEditingTicketTypesManually}`);
    setCustomSeatingMap(newSeatingMap);
    
    // Only auto-update ticket types if user hasn't manually edited them
    if (!isEditingTicketTypesManually) {
      console.log(`üîÑ AUTO-UPDATE MODE: Creating new ticket types from sections`);
      // Auto-update ticket types based on sections - preserve existing colors
      const newTicketTypes = [];
      const sectionTicketTypes = new Set();
      
      newSeatingMap.sections.forEach(section => {
        if (section.ticketType && !sectionTicketTypes.has(section.ticketType)) {
          sectionTicketTypes.add(section.ticketType);
          const existingTicketType = ticketTypes.find(tt => tt.name === section.ticketType);
          
          // Calculate total capacity for this ticket type across all sections
          const totalCapacityForType = newSeatingMap.sections
            .filter(s => s.ticketType === section.ticketType)
            .reduce((sum, s) => sum + (s.capacity || 0), 0);
          
          newTicketTypes.push({
            name: section.ticketType,
            price: existingTicketType?.price || 300000,
            description: existingTicketType?.description || `V√© ${section.ticketType}`,
            quantity: totalCapacityForType,
            color: existingTicketType?.color || getDefaultColorForTicketType(section.ticketType)
          });
        }
      });
      
      if (newTicketTypes.length > 0) {
        console.log(`üîÑ AUTO-UPDATE: Replacing ${ticketTypes.length} ticket types with ${newTicketTypes.length} new ones`);
        setTicketTypes(newTicketTypes);
        console.log('üé® Auto-updated ticket types with preserved colors:', newTicketTypes);
      }
    } else {
      console.log(`üéõÔ∏è MANUAL MODE: Only updating quantities for existing ticket types`);
      // User is manually editing, only update quantities for matching ticket types
      const updatedTicketTypes = ticketTypes.map(tt => {
        const totalCapacityForType = newSeatingMap.sections
          .filter(s => s.ticketType === tt.name)
          .reduce((sum, s) => sum + (s.capacity || 0), 0);
        
        // Only update quantity if there are sections with this ticket type
        if (totalCapacityForType > 0) {
          return { ...tt, quantity: totalCapacityForType };
        }
        return tt;
      });
      
      setTicketTypes(updatedTicketTypes);
      console.log('üîÑ Updated quantities only for existing ticket types (manual mode):', updatedTicketTypes);
    }
  };

  // Helper function to get default color for ticket type
  const getDefaultColorForTicketType = (ticketTypeName) => {
    const colorMap = {
      'VIP': '#8B5CF6',
      'Premium': '#F59E0B',
      'Standard': '#3B82F6',
      'Economy': '#10B981',
      'Golden': '#FFD700',
      'Silver': '#C0C0C0'
    };
    
    return colorMap[ticketTypeName] || '#6B7280';
  };

  // Auto-arrange sections to prevent overlapping
  const autoArrangeSections = (seatingMap) => {
    if (!seatingMap || !seatingMap.sections || seatingMap.sections.length === 0) {
      return seatingMap;
    }

    const arrangedMap = { ...seatingMap };
    let sections = [...arrangedMap.sections];
    
    // Helper function to check if two rectangles overlap
    const isOverlapping = (rect1, rect2) => {
      const margin = 30; // Minimum margin between sections
      return !(
        rect1.x + (rect1.width || 150) + margin <= rect2.x ||
        rect2.x + (rect2.width || 150) + margin <= rect1.x ||
        rect1.y + (rect1.height || 100) + margin <= rect2.y ||
        rect2.y + (rect2.height || 100) + margin <= rect1.y
      );
    };

    // Smart grid-based arrangement
    const arrangeInGrid = (sections) => {
      // Calculate stage position for reference
      const stage = seatingMap.stage || { x: 400, y: 50, width: 200, height: 60 };
      
      // Sort sections by distance from stage (VIP sections closer)
      const sortedSections = [...sections].sort((a, b) => {
        const distA = Math.sqrt(Math.pow(a.x - stage.x, 2) + Math.pow(a.y - stage.y, 2));
        const distB = Math.sqrt(Math.pow(b.x - stage.x, 2) + Math.pow(b.y - stage.y, 2));
        return distA - distB;
      });

      const arrangedSections = [];
      const sectionWidth = 180; // Standard width with margin
      const sectionHeight = 130; // Standard height with margin
      const startX = Math.max(50, stage.x - sectionWidth * 2);
      const startY = stage.y + (stage.height || 60) + 50; // Below stage
      
      let currentRow = 0;
      let currentCol = 0;
      const maxCols = Math.floor(1000 / sectionWidth); // Max sections per row
      
      sortedSections.forEach((section, index) => {
        // Try original position first if it doesn't overlap
        let finalX = section.x;
        let finalY = section.y;
        let needsRepositioning = false;
        
        // Check if original position overlaps with arranged sections
        const testSection = { ...section, x: finalX, y: finalY };
        const hasOverlap = arrangedSections.some(arranged => 
          isOverlapping(testSection, arranged)
        );
        
        // Also check if too close to stage
        const tooCloseToStage = isOverlapping(testSection, stage);
        
        if (hasOverlap || tooCloseToStage) {
          needsRepositioning = true;
          
          // Use grid positioning
          finalX = startX + (currentCol * sectionWidth);
          finalY = startY + (currentRow * sectionHeight);
          
          // If still overlaps, try next position
          let attempts = 0;
          while (attempts < maxCols * 5) {
            const gridTestSection = { ...section, x: finalX, y: finalY };
            const gridHasOverlap = arrangedSections.some(arranged => 
              isOverlapping(gridTestSection, arranged)
            );
            
            if (!gridHasOverlap && !isOverlapping(gridTestSection, stage)) {
              break;
            }
            
            // Move to next grid position
            currentCol++;
            if (currentCol >= maxCols) {
              currentCol = 0;
              currentRow++;
            }
            
            finalX = startX + (currentCol * sectionWidth);
            finalY = startY + (currentRow * sectionHeight);
            attempts++;
          }
          
          console.log(`üîß Auto-arranged section "${section.name}" from (${section.x}, ${section.y}) to (${finalX}, ${finalY})`);
        }
        
        arrangedSections.push({
          ...section,
          x: finalX,
          y: finalY
        });
        
        // Move to next grid position for next section that needs repositioning
        if (needsRepositioning) {
          currentCol++;
          if (currentCol >= maxCols) {
            currentCol = 0;
            currentRow++;
          }
        }
      });
      
      return arrangedSections;
    };

    // Apply smart arrangement
    const finalSections = arrangeInGrid(sections);
    arrangedMap.sections = finalSections;
    
    console.log(`üéØ Auto-arrange completed: ${finalSections.length} sections arranged`);
    return arrangedMap;
  };

  // Switch between design modes
  const handleDesignModeChange = (mode) => {
    setDesignMode(mode);
    
    // Reset manual editing flag when switching design mode
    setIsEditingTicketTypesManually(false);
    
    if (mode === 'custom') {
      // Initialize custom map with current template if available
      if (previewSeatingMap && previewSeatingMap.sections.length > 0) {
        setCustomSeatingMap({
          ...previewSeatingMap,
          layoutType: 'custom'
        });
      }
    }
  };

  return (
    <div className="create-event-container">
      <div className="create-event-header">
        <h2>üé™ T·∫°o S·ª± Ki·ªán C√≥ Ch·ªó Ng·ªìi</h2>
        <p>T·∫°o s·ª± ki·ªán v·ªõi h·ªá th·ªëng qu·∫£n l√Ω ch·ªó ng·ªìi th√¥ng minh</p>
        
        {templateInfo && (
          <div className="text-center mb-4">
            <span className="bg-blue-600 text-white px-4 py-2 rounded-full text-sm">
              üìã Template: {templateInfo.templateName}
            </span>
          </div>
        )}
        
        {/* Progress indicator */}
        <div className="progress-indicator">
          <div className={`step ${currentStep >= 1 ? 'active' : ''}`}>1. Template</div>
          <div className={`step ${currentStep >= 2 ? 'active' : ''}`}>2. Th√¥ng tin</div>
          <div className={`step ${currentStep >= 3 ? 'active' : ''}`}>3. C·∫•u h√¨nh</div>
          <div className={`step ${currentStep >= 4 ? 'active' : ''}`}>4. X√°c nh·∫≠n</div>
        </div>
      </div>

      {message && (
        <div className={`message ${message.includes('th√†nh c√¥ng') ? 'success' : 'error'}`}>
          {message}
        </div>
      )}

      <form onSubmit={handleSubmit} className="create-event-form">
        
        {/* Step 1: Venue Template Selection */}
        {currentStep === 1 && (
          <div className="form-section">
            <h3>üèüÔ∏è Ch·ªçn Lo·∫°i ƒê·ªãa ƒêi·ªÉm</h3>
            <p>Ch·ªçn template ph√π h·ª£p v·ªõi s·ª± ki·ªán c·ªßa b·∫°n ƒë·ªÉ ƒë∆∞·ª£c t·ª± ƒë·ªông c·∫•u h√¨nh t·ªëi ∆∞u</p>
            
            <div className="venue-templates">
              {Object.entries(VENUE_TEMPLATES).map(([key, template]) => (
                <div 
                  key={key}
                  className={`venue-template ${selectedVenueTemplate === key ? 'selected' : ''}`}
                  onClick={() => applyVenueTemplate(key)}
                >
                  <h4>{template.name}</h4>
                  <p>{template.description}</p>
                  <div className="template-stats">
                    <span>üìç {template.defaultSections} khu v·ª±c</span>
                    <span>ü™ë {template.defaultSeats} gh·∫ø</span>
                    <span>üé´ {template.ticketTypeTemplates.length} lo·∫°i v√©</span>
                  </div>
                </div>
              ))}
            </div>
            
            <div className="step-actions">
              <button type="button" onClick={nextStep} disabled={!selectedVenueTemplate}>
                Ti·∫øp theo ‚Üí
              </button>
            </div>
          </div>
        )}

        {/* Step 2: Basic Event Info */}
        {currentStep === 2 && (
          <div className="form-section">
            <h3>üìù Th√¥ng Tin S·ª± Ki·ªán</h3>
            
            {/* Upload Images Section */}
            <div className="form-section">
              <h4>üñºÔ∏è H√¨nh ·∫¢nh S·ª± Ki·ªán</h4>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                <ImageUpload
                  image={eventData.images.logo}
                  handleImageUpload={handleImageUpload}
                  type="logo"
                  title="Th√™m logo s·ª± ki·ªán"
                  description="(T·ª∑ l·ªá 720x950, t·ªëi ƒëa 5MB)"
                />
                <ImageUpload
                  image={eventData.images.banner}
                  handleImageUpload={handleImageUpload}
                  type="banner"
                  title="Th√™m ·∫£nh n·ªÅn s·ª± ki·ªán"
                  description="(T·ª∑ l·ªá 1200x720, t·ªëi ƒëa 10MB)"
                />
              </div>
            </div>
            
            <div className="form-group">
              <label htmlFor="title">T√™n s·ª± ki·ªán *</label>
              <input
                type="text"
                id="title"
                name="title"
                value={eventData.title}
                onChange={handleEventDataChange}
                placeholder="V√≠ d·ª•: Concert nh·∫°c pop 2024"
                required
              />
            </div>

            <div className="form-group">
              <label htmlFor="description">M√¥ t·∫£ ng·∫Øn *</label>
              <textarea
                id="description"
                name="description"
                value={eventData.description}
                onChange={handleEventDataChange}
                placeholder="M√¥ t·∫£ ng·∫Øn g·ªçn v·ªÅ s·ª± ki·ªán"
                rows="3"
                required
              />
            </div>

            <div className="form-row">
              <div className="form-group">
                <label htmlFor="startDate">Ng√†y b·∫Øt ƒë·∫ßu *</label>
                <input
                  type="datetime-local"
                  id="startDate"
                  name="startDate"
                  value={eventData.startDate}
                  onChange={handleEventDataChange}
                  required
                />
              </div>

              <div className="form-group">
                <label htmlFor="endDate">Ng√†y k·∫øt th√∫c *</label>
                <input
                  type="datetime-local"
                  id="endDate"
                  name="endDate"
                  value={eventData.endDate}
                  onChange={handleEventDataChange}
                  required
                />
              </div>
            </div>

            {/* Location */}
            <div className="form-group">
              <label htmlFor="venueName">T√™n ƒë·ªãa ƒëi·ªÉm</label>
              <input
                type="text"
                id="venueName"
                name="location.venueName"
                value={eventData.location.venueName}
                onChange={handleEventDataChange}
                placeholder="V√≠ d·ª•: S√¢n v·∫≠n ƒë·ªông M·ªπ ƒê√¨nh"
              />
            </div>

            <div className="form-group">
              <label htmlFor="address">ƒê·ªãa ch·ªâ</label>
              <input
                type="text"
                id="address"
                name="location.address"
                value={eventData.location.address}
                onChange={handleEventDataChange}
                placeholder="ƒê·ªãa ch·ªâ c·ª• th·ªÉ"
              />
            </div>

            {/* Organizer Information Section */}

            
            <div className="step-actions">
              <button type="button" onClick={prevStep}>‚Üê Quay l·∫°i</button>
              <button type="button" onClick={nextStep}>Ti·∫øp theo ‚Üí</button>
            </div>
          </div>
        )}

        {/* Step 3: Seat & Ticket Configuration */}
        {currentStep === 3 && (
          <>
            {/* Design Mode Selection */}
            <div className="form-section">
              <h3>üé≠ Thi·∫øt k·∫ø s∆° ƒë·ªì ch·ªó ng·ªìi</h3>
              <p>Ch·ªçn c√°ch b·∫°n mu·ªën thi·∫øt k·∫ø s∆° ƒë·ªì ch·ªó ng·ªìi cho s·ª± ki·ªán</p>
              
              <div className="design-mode-selector">
                <div 
                  className={`design-mode-option ${designMode === 'template' ? 'selected' : ''}`}
                  onClick={() => handleDesignModeChange('template')}
                >
                  <div className="mode-icon">üìã</div>
                  <h4>S·ª≠ d·ª•ng Template</h4>
                  <p>D√πng template c√≥ s·∫µn v·ªõi layout t·ª± ƒë·ªông</p>
                  <ul>
                    <li>‚úÖ Nhanh ch√≥ng, ƒë∆°n gi·∫£n</li>
                    <li>‚úÖ Layout ƒë∆∞·ª£c t·ªëi ∆∞u s·∫µn</li>
                    <li>‚úÖ Ph√π h·ª£p cho s·ª± ki·ªán c∆° b·∫£n</li>
                  </ul>
                </div>
                
                <div 
                  className={`design-mode-option ${designMode === 'custom' ? 'selected' : ''}`}
                  onClick={() => handleDesignModeChange('custom')}
                >
                  <div className="mode-icon">üé®</div>
                  <h4>Thi·∫øt k·∫ø t√πy ch·ªânh</h4>
                  <p>K√©o th·∫£ v√† t√πy ch·ªânh t·ª´ng khu v·ª±c</p>
                  <ul>
                    <li>üéØ Linh ho·∫°t 100%</li>
                    <li>üéØ T√πy ch·ªânh v·ªã tr√≠ t·ª± do</li>
                    <li>üéØ Ph√π h·ª£p cho s·ª± ki·ªán ph·ª©c t·∫°p</li>
                  </ul>
                </div>
              </div>
            </div>

            {/* Template Mode */}
            {designMode === 'template' && (
              <div className="form-section">
                <h3>ü™ë C·∫•u H√¨nh Gh·∫ø Ng·ªìi (Template)</h3>
              <p>Template ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh t·ª± ƒë·ªông. B·∫°n c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh theo nhu c·∫ßu.</p>
              
              <div className="form-row">
                <div className="form-group">
                  <label htmlFor="totalSeats">T·ªïng s·ªë gh·∫ø *</label>
                  <input
                    type="number"
                    id="totalSeats"
                    name="totalSeats"
                    value={seatOptions.totalSeats}
                    onChange={handleSeatOptionsChange}
                    min="1"
                    max="1000"
                    required
                  />
                  <small>S·ªë v√© s·∫Ω ƒë∆∞·ª£c ƒëi·ªÅu ch·ªânh t·ª± ƒë·ªông theo t·ª∑ l·ªá</small>
                </div>

                <div className="form-group">
                  <label htmlFor="totalSections">S·ªë khu v·ª±c *</label>
                  <input
                    type="number"
                    id="totalSections"
                    name="totalSections"
                    value={seatOptions.totalSections}
                    onChange={handleSeatOptionsChange}
                    min="1"
                    max="20"
                    required
                  />
                  <small>Layout {selectedVenueTemplate} v·ªõi {seatOptions.totalSections} khu</small>
                </div>
              </div>

              {/* Live Seating Preview */}
              <div className="seating-preview-section">
                <h4>üéØ Xem Tr∆∞·ªõc S∆° ƒê·ªì Gh·∫ø</h4>
                <p>{seatOptions.totalSeats} gh·∫ø ph√¢n b·ªë th√¥ng minh trong {seatOptions.totalSections} khu v·ª±c theo layout {selectedVenueTemplate}</p>
                
                {previewSeatingMap ? (
                  <SeatingPreview 
                    seatingMap={previewSeatingMap} 
                    showLabels={true}
                    interactive={false}
                  />
                ) : (
                  <div className="preview-loading">
                    <p>üîÑ ƒêang t·∫°o preview...</p>
                    <small>H√£y ch·ªçn template v√† c·∫•u h√¨nh ƒë·ªÉ xem preview</small>
                  </div>
                )}
                
                <div className="preview-actions">
                  <button 
                    type="button" 
                    onClick={() => generatePreviewMap()}
                    className="btn-secondary"
                  >
                    üîÑ C·∫≠p nh·∫≠t preview
                  </button>
                </div>
              </div>
            </div>
            )}

            {/* Custom Mode */}
            {designMode === 'custom' && (
              <div className="form-section">
                <h3>üé® Thi·∫øt k·∫ø s∆° ƒë·ªì t√πy ch·ªânh</h3>
                <p>K√©o th·∫£ c√°c khu v·ª±c, s√¢n kh·∫•u ƒë·ªÉ t·∫°o layout ph√π h·ª£p v·ªõi s·ª± ki·ªán c·ªßa b·∫°n</p>
                
                {/* Info about auto-arrange */}
                <div className="info-box">
                  <p>‚ÑπÔ∏è <strong>L∆∞u √Ω:</strong> Khi t·∫°o s·ª± ki·ªán, h·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông cƒÉn ch·ªânh c√°c sections ƒë·ªÉ tr√°nh ch·ªìng l·∫•p, nh∆∞ng v·∫´n gi·ªØ nguy√™n layout t·ªïng th·ªÉ m√† b·∫°n ƒë√£ thi·∫øt k·∫ø.</p>
                </div>
                
                {/* Auto-arrange button */}
                <div className="auto-arrange-section">
                  <button
                    type="button"
                    className="btn-secondary"
                    onClick={() => {
                      console.log('üîß Manual auto-arrange triggered');
                      const arrangedMap = autoArrangeSections(customSeatingMap);
                      setCustomSeatingMap(arrangedMap);
                      console.log('‚úÖ Sections auto-arranged manually');
                    }}
                  >
                    üîß Xem tr∆∞·ªõc cƒÉn ch·ªânh t·ª± ƒë·ªông
                  </button>
                  <small>Ki·ªÉm tra c√°ch h·ªá th·ªëng s·∫Ω cƒÉn ch·ªânh c√°c sections ƒë·ªÉ tr√°nh ch·ªìng l·∫•p</small>
                </div>
                
                <InteractiveSeatingDesigner
                  initialSeatingMap={customSeatingMap}
                  onSeatingMapChange={handleCustomSeatingMapChange}
                  ticketTypes={ticketTypes}
                  onTicketTypesChange={setTicketTypes}
                  layoutType={selectedVenueTemplate}
                />
              </div>
            )}

            {/* Ticket Types */}
            <div className="form-section">
              <h3>üé´ Lo·∫°i V√©</h3>
              <p>ƒê√£ ƒë∆∞·ª£c c·∫•u h√¨nh t·ª± ƒë·ªông d·ª±a tr√™n template. ƒêi·ªÅu ch·ªânh gi√° v√† s·ªë l∆∞·ª£ng n·∫øu c·∫ßn.</p>
              
              {/* Manual editing indicator */}
              {isEditingTicketTypesManually && designMode === 'custom' && (
                <div className="manual-editing-indicator">
                  <p>üìù B·∫°n ƒëang ch·ªânh s·ª≠a th·ªß c√¥ng. Ticket types s·∫Ω kh√¥ng t·ª± ƒë·ªông sync v·ªõi seating map.</p>
                  <button
                    type="button"
                    className="btn-secondary"
                    onClick={() => setIsEditingTicketTypesManually(false)}
                  >
                    üîÑ B·∫≠t l·∫°i Auto-sync v·ªõi seating map
                  </button>
                </div>
              )}
              
              {ticketTypes.map((ticketType, index) => (
                <div key={index} className="ticket-type-item">
                  <div className="ticket-type-header">
                    <h4>üé´ {ticketType.name || `Lo·∫°i v√© ${index + 1}`}</h4>
                    {ticketTypes.length > 1 && (
                      <button
                        type="button"
                        className="remove-ticket-type"
                        onClick={() => removeTicketType(index)}
                      >
                        X√≥a
                      </button>
                    )}
                  </div>

                  <div className="form-row">
                    <div className="form-group">
                      <label>T√™n lo·∫°i v√© *</label>
                      <input
                        type="text"
                        value={ticketType.name}
                        onChange={(e) => handleTicketTypeChange(index, 'name', e.target.value)}
                        placeholder="VIP, Th∆∞·ªùng, ..."
                        required
                      />
                    </div>

                    <div className="form-group">
                      <label>Gi√° (VND) *</label>
                      <input
                        type="number"
                        value={ticketType.price}
                        onChange={(e) => handleTicketTypeChange(index, 'price', e.target.value)}
                        min="0"
                        placeholder="500000"
                        required
                      />
                    </div>

                    <div className="form-group">
                      <label>S·ªë l∆∞·ª£ng *</label>
                      <input
                        type="number"
                        value={ticketType.quantity}
                        onChange={(e) => handleTicketTypeChange(index, 'quantity', e.target.value)}
                        min="0"
                        max={seatOptions.totalSeats}
                        required
                      />
                    </div>

                    <div className="form-group">
                      <label>M√†u s·∫Øc</label>
                      <div className="color-picker-container">
                        <input
                          type="color"
                          value={ticketType.color || '#6B7280'}
                          onChange={(e) => handleTicketTypeChange(index, 'color', e.target.value)}
                          className="color-picker"
                        />
                        <span className="color-preview" style={{ backgroundColor: ticketType.color || '#6B7280' }}></span>
                      </div>
                    </div>
                  </div>

                  <div className="form-group">
                    <label>M√¥ t·∫£</label>
                    <textarea
                      value={ticketType.description}
                      onChange={(e) => handleTicketTypeChange(index, 'description', e.target.value)}
                      placeholder="M√¥ t·∫£ v·ªÅ lo·∫°i v√© n√†y"
                      rows="2"
                    />
                  </div>
                </div>
              ))}

              <button
                type="button"
                className="add-ticket-type"
                onClick={addTicketType}
              >
                + Th√™m lo·∫°i v√©
              </button>

              <div className="ticket-summary">
                <p><strong>üìä T·ªïng s·ªë v√©:</strong> {ticketTypes.reduce((sum, tt) => sum + tt.quantity, 0)} / {seatOptions.totalSeats} gh·∫ø</p>
                <p><strong>üí∞ Doanh thu d·ª± ki·∫øn:</strong> {ticketTypes.reduce((sum, tt) => sum + (tt.price * tt.quantity), 0).toLocaleString('vi-VN')} VND</p>
              </div>
            </div>
            
            <div className="step-actions">
              <button type="button" onClick={prevStep}>‚Üê Quay l·∫°i</button>
              <button type="button" onClick={nextStep}>Ti·∫øp theo ‚Üí</button>
            </div>
          </>
        )}

        {/* Step 4: Confirmation */}
        {currentStep === 4 && (
          <div className="form-section">
            <h3>‚úÖ X√°c Nh·∫≠n T·∫°o S·ª± Ki·ªán</h3>
            
            <div className="confirmation-summary">
              <div className="summary-item">
                <h4>üìù Th√¥ng tin s·ª± ki·ªán</h4>
                <p><strong>T√™n:</strong> {eventData.title}</p>
                <p><strong>ƒê·ªãa ƒëi·ªÉm:</strong> {eventData.location.venueName || 'Ch∆∞a c√≥'}</p>
                <p><strong>Th·ªùi gian:</strong> {new Date(eventData.startDate).toLocaleString('vi-VN')} - {new Date(eventData.endDate).toLocaleString('vi-VN')}</p>
              </div>
              
              <div className="summary-item">
                <h4>üèüÔ∏è Layout s·ª± ki·ªán</h4>
                <p><strong>Template:</strong> {VENUE_TEMPLATES[selectedVenueTemplate]?.name}</p>
                <p><strong>T·ªïng gh·∫ø:</strong> {seatOptions.totalSeats}</p>
                <p><strong>S·ªë khu:</strong> {seatOptions.totalSections}</p>
              </div>
              
              <div className="summary-item">
                <h4>üé´ Danh s√°ch v√©</h4>
                {ticketTypes.map((tt, index) => (
                  <p key={index}><strong>{tt.name}:</strong> {tt.quantity} v√© √ó {tt.price.toLocaleString('vi-VN')} VND</p>
                ))}
                <p><strong>üí∞ T·ªïng doanh thu d·ª± ki·∫øn:</strong> {ticketTypes.reduce((sum, tt) => sum + (tt.price * tt.quantity), 0).toLocaleString('vi-VN')} VND</p>
              </div>
            </div>

            <div className="form-group">
              <label htmlFor="termsAndConditions">ƒêi·ªÅu kho·∫£n v√† ƒëi·ªÅu ki·ªán</label>
              <textarea
                id="termsAndConditions"
                name="termsAndConditions"
                value={eventData.termsAndConditions}
                onChange={handleEventDataChange}
                placeholder="C√°c quy ƒë·ªãnh v√† ƒëi·ªÅu ki·ªán tham gia s·ª± ki·ªán"
                rows="4"
              />
            </div>
            
            <div className="step-actions">
              <button type="button" onClick={prevStep}>‚Üê Quay l·∫°i</button>
              <button
                type="submit"
                className="submit-btn primary"
                disabled={loading}
              >
                {loading ? 'üîÑ ƒêang t·∫°o...' : 'üéâ T·∫°o S·ª± Ki·ªán'}
              </button>
            </div>
          </div>
        )}
      </form>
    </div>
  );
};

export default CreateEventWithSeating; 